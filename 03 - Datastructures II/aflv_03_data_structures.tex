\documentclass[12pt,t]{beamer}
\subtitle{3 -- Data Structures}
\newcommand{\shorttitle}{Data Structures}
\input{../acmlecture.tex}

\begin{frame}{Today we're going to cover}
    \vspace{40pt}
    \bi
        \item Study range queries
        \item Learn about Segment Trees
        \item Learn about Fenwick Trees
    \ei
\end{frame}

\begin{frame}{Augmenting Data Structures}
    \bi
        \item Sometimes we can store extra information in our data structures to gain more functionality
        \item Usually we can't do this to data structures in the standard library
        \item Need our own implementation that we can customize
        \item Example: Augmenting binary search trees
    \ei
\end{frame}

\begin{frame}[fragile]{Augmenting Binary Search Trees}

    \begin{columns}[T]
        \begin{column}{.45\textwidth}
            \vspace{20pt}

            \bi
                \item We have a binary search tree and want to efficiently:
                    \bi
                        \item Count number of elements $<x$
                        \item Find the $k$th smallest element
                    \ei

                \item Naive method is to go through all vertices, but that is slow: $O(n)$
            \ei
        \end{column}%
        \hfill%
        \begin{column}{.55\textwidth}
            \begin{figure}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  vertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=black,
    text width=1.8em},% arbre rouge noir, noeud noir
}

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5.5cm/#1,
  level distance = 1.8cm},scale=0.6] 
\node [vertex] {33}
    child{ node [vertex] {15}
            child{ node [vertex] {10} 
            	child{ node [vertex] {5} } %for a named pointer
                % child{ node [vertex] {}}
            }
            child{ node [vertex] {20}
							child{ node [vertex] {18}}
							% child{ node [vertex] {}}
            }                            
    }
    child{ node [vertex] {47}
            child{ node [vertex] {38} 
							child{ node [vertex] {36}
                                child { node [vertex] {34} }
                                child { node [vertex] {37} }
                            }
							child{ node [vertex] {39}}
            }
            child{ node [vertex] {51}
							child{ node [vertex] {49}}
							% child{ node [vertex] {}}
            }
		}
; 
\end{tikzpicture}
            \end{figure}
        \end{column}%
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Augmenting Binary Search Trees}

    \begin{columns}[T]
        \begin{column}{.45\textwidth}
            \vspace{20pt}

            \bi
                \item Idea: In each vertex store the size of the subtree
                \item This information can be maintained when we insert/delete elements without adding time complexity
            \ei
        \end{column}%
        \hfill%
        \begin{column}{.55\textwidth}
            \begin{figure}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
   vertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=black,
    text width=1.8em},% arbre rouge noir, noeud noir
}

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5.5cm/#1,
  level distance = 1.8cm},scale=0.6] 
\node [vertex] {\mbox{\ 33, 14}}
    child{ node [vertex] {\mbox{\ 15, 5}}
            child{ node [vertex] {\mbox{\ 10, 2}} 
            	child{ node [vertex] {\mbox{\ 5, 1}} } %for a named pointer
                % child{ node [vertex] {}}
            }
            child{ node [vertex] {\mbox{\ 20, 2}}
							child{ node [vertex] {\mbox{\ 18, 1}}}
							% child{ node [vertex] {}}
            }                            
    }
    child{ node [vertex] {\mbox{\ 47, 8}}
            child{ node [vertex] {\mbox{\ 38, 5} }
                            child{ node [vertex] {\mbox{\ 36, 3}}
                                child { node [vertex] {\mbox{\ 34, 1}} }
                                child { node [vertex] {\mbox{\ 37, 1}} }
                            }
							child{ node [vertex] {\mbox{\ 39, 1}}}
            }
            child{ node [vertex] {\mbox{\ 51, 2}}
							child{ node [vertex] {\mbox{\ 49, 1}}}
							% child{ node [vertex] {}}
            }
		}
; 
\end{tikzpicture}
            \end{figure}
        \end{column}%
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Augmenting Binary Search Trees}

    \begin{columns}[T]
        \begin{column}{.45\textwidth}
            \bi
                \item Count number of elements $<38$
                    \bi
                        \item Search for $38$ in the tree
                        \item Count the vertices that we pass by that are less than $x$
                        \item When we are at a vertex where we should go right, get the size of the left subtree and add it to our count
                    \ei
            \ei
        \end{column}%
        \hfill%
        \begin{column}{.55\textwidth}
            \begin{figure}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
   vertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=black,
    text width=1.8em},% arbre rouge noir, noeud noir
}

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5.5cm/#1,
  level distance = 1.8cm},scale=0.6] 
\node [vertex] {\mbox{\ 33, 14}}
    child{ node [vertex] {\mbox{\ 15, 5}}
            child{ node [vertex] {\mbox{\ 10, 2}} 
            	child{ node [vertex] {\mbox{\ 5, 1}} } %for a named pointer
                % child{ node [vertex] {}}
            }
            child{ node [vertex] {\mbox{\ 20, 2}}
							child{ node [vertex] {\mbox{\ 18, 1}}}
							% child{ node [vertex] {}}
            }                            
    }
    child{ node [vertex] {\mbox{\ 47, 8}}
            child{ node [vertex] {\mbox{\ 38, 5} }
                            child{ node [vertex] {\mbox{\ 36, 3}}
                                child { node [vertex] {\mbox{\ 34, 1}} }
                                child { node [vertex] {\mbox{\ 37, 1}} }
                            }
							child{ node [vertex] {\mbox{\ 39, 1}}}
            }
            child{ node [vertex] {\mbox{\ 51, 2}}
							child{ node [vertex] {\mbox{\ 49, 1}}}
							% child{ node [vertex] {}}
            }
		}
; 
\end{tikzpicture}
            \end{figure}
        \end{column}%
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Augmenting Binary Search Trees}

    \begin{columns}[T]
        \begin{column}{.45\textwidth}
            \bi
                \item Count number of elements $<38$
                    \bi
                        \item Search for $38$ in the tree
                        \item Count the vertices that we pass by that are less than $x$
                        \item When we are at a vertex where we should go right, get the size of the left subtree and add it to our count
                    \ei
                \vspace{2pt}
                \item Time complexity $O(\log n)$
            \ei
        \end{column}%
        \hfill%
        \begin{column}{.55\textwidth}
            \begin{figure}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  vertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=black, text width=1.8em},% arbre rouge noir, noeud noir
  rvertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=red, text width=1.8em},% arbre rouge noir, noeud noir
}

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5.5cm/#1,
  level distance = 1.8cm},scale=0.6] 
\node [rvertex] {\mbox{\ 33, 14}}
    child{ node [vertex] {\mbox{\ 15, {\color{red}5}}}
            child{ node [vertex] {\mbox{\ 10, 2}} 
            	child{ node [vertex] {\mbox{\ 5, 1}} } %for a named pointer
                % child{ node [vertex] {}}
            }
            child{ node [vertex] {\mbox{\ 20, 2}}
							child{ node [vertex] {\mbox{\ 18, 1}}}
							% child{ node [vertex] {}}
            }                            
    }
    child{ node [rvertex] {\mbox{\ 47, 8}}
            child{ node [rvertex] {\mbox{\ 38, 5} }
                            child{ node [vertex] {\mbox{\ 36, {\color{red}3}}}
                                child { node [vertex] {\mbox{\ 34, 1}} }
                                child { node [vertex] {\mbox{\ 37, 1}} }
                            }
							child{ node [vertex] {\mbox{\ 39, 1}}}
            }
            child{ node [vertex] {\mbox{\ 51, 2}}
							child{ node [vertex] {\mbox{\ 49, 1}}}
							% child{ node [vertex] {}}
            }
		}
; 
\end{tikzpicture}
            \end{figure}
        \end{column}%
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Augmenting Binary Search Trees}

    \begin{columns}[T]
        \begin{column}{.45\textwidth}
            \bi
                \item Find $k$th smallest element
                    \bi
                        \item We're on a vertex whose left subtree is of size $m$
                        \item If $k = m+1$, we found it
                        \item If $k \leq m$, look for the $k$th smallest element in the left subtree
                        \item If $k > m+1$, look for the $k-m-1$st smallest element in the right subtree
                    \ei
                \vspace{2pt}
            \ei
        \end{column}%
        \hfill%
        \begin{column}{.55\textwidth}
            \begin{figure}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  vertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=black, text width=1.8em},% arbre rouge noir, noeud noir
  rvertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=red, text width=1.8em},% arbre rouge noir, noeud noir
}

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5.5cm/#1,
  level distance = 1.8cm},scale=0.6] 
\node [vertex] {\mbox{\ 33, 14}}
    child{ node [vertex] {\mbox{\ 15, 5}}
            child{ node [vertex] {\mbox{\ 10, 2}} 
            	child{ node [vertex] {\mbox{\ 5, 1}} } %for a named pointer
                % child{ node [vertex] {}}
            }
            child{ node [vertex] {\mbox{\ 20, 2}}
							child{ node [vertex] {\mbox{\ 18, 1}}}
							% child{ node [vertex] {}}
            }                            
    }
    child{ node [vertex] {\mbox{\ 47, 8}}
            child{ node [vertex] {\mbox{\ 38, 5} }
                            child{ node [vertex] {\mbox{\ 36, 3}}
                                child { node [vertex] {\mbox{\ 34, 1}} }
                                child { node [vertex] {\mbox{\ 37, 1}} }
                            }
							child{ node [vertex] {\mbox{\ 39, 1}}}
            }
            child{ node [vertex] {\mbox{\ 51, 2}}
							child{ node [vertex] {\mbox{\ 49, 1}}}
							% child{ node [vertex] {}}
            }
		}
; 
\end{tikzpicture}
            \end{figure}
        \end{column}%
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Augmenting Binary Search Trees}

    \begin{columns}[T]
        \begin{column}{.45\textwidth}
            \bi
                \item Find $k$th smallest element
                    \bi
                        \item We're on a vertex whose left subtree is of size $m$
                        \item If $k = m+1$, we found it
                        \item If $k \leq m$, look for the $k$th smallest element in the left subtree
                        \item If $k > m+1$, look for the $k-m-1$st smallest element in the right subtree
                    \ei
                \item Example: $k=11$
            \ei
        \end{column}%
        \hfill%
        \begin{column}{.55\textwidth}
            \begin{figure}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  vertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=black, text width=1.8em},% arbre rouge noir, noeud noir
  rvertex/.style = {treenode, circle, black, font=\sffamily\bfseries\tiny, draw=red, text width=1.8em},% arbre rouge noir, noeud noir
}

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5.5cm/#1,
  level distance = 1.8cm},scale=0.6] 
\node [rvertex] {\mbox{\ 33, 14}}
    child{ node [vertex] {\mbox{\ 15, 5}}
            child{ node [vertex] {\mbox{\ 10, 2}} 
            	child{ node [vertex] {\mbox{\ 5, 1}} } %for a named pointer
                % child{ node [vertex] {}}
            }
            child{ node [vertex] {\mbox{\ 20, 2}}
							child{ node [vertex] {\mbox{\ 18, 1}}}
							% child{ node [vertex] {}}
            }                            
    }
    child{ node [rvertex] {\mbox{\ 47, 8}}
            child{ node [rvertex] {\mbox{\ 38, 5} }
                            child{ node [vertex] {\mbox{\ 36, 3}}
                                child { node [vertex] {\mbox{\ 34, 1}} }
                                child { node [vertex] {\mbox{\ 37, 1}} }
                            }
							child{ node [rvertex] {\mbox{\ 39, 1}}}
            }
            child{ node [vertex] {\mbox{\ 51, 2}}
							child{ node [vertex] {\mbox{\ 49, 1}}}
							% child{ node [vertex] {}}
            }
		}
; 
\end{tikzpicture}
            \end{figure}
        \end{column}%
    \end{columns}
\end{frame}

%\begin{frame}[fragile]{Example}
%
%    \bi
%      \item 11991 - only construct the tree
%      \item 10909 - remove elements
%    \ei
%\end{frame}




% TODO: Range queries
\begin{frame}{Range queries}
    \vspace{30pt}
    \bi
        \item We have an array $A$ of size $n$
        \item Given $i,j$, we want to answer:
            \bi
                \item $\mathrm{max}(A[i],A[i+1],\ldots,A[j-1],A[j])$
                \item $\mathrm{min}(A[i],A[i+1],\ldots,A[j-1],A[j])$
                \item $\mathrm{sum}(A[i],A[i+1],\ldots,A[j-1],A[j])$
            \ei
        \item We want to answer these queries efficiently, i.e.\ without looking through all elements
        \item Sometimes we also want to update elements
    \ei
\end{frame}

% TODO: Range sum on a static array
\begin{frame}{Range sum on a static array}
    \bi
        \item Let's look at range sums on a static array \\(i.e.\ updating is not supported)
    \ei

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            \color<2,3>{vhilight}{1} & \color<2,3>{vhilight}{0} & \color<2,3,4,5,6,7>{vhilight}{7} & \color<2,3,4,5>{vhilight}{8} & \color<2,3,4,5>{vhilight}{5} & \color<2,3,4,5>{vhilight}{9} & \color<2,3>{vhilight}{3} \\
            \hline
        \end{tabular}
    \end{center}

    \bi
        \onslide<2->{\item $\mathrm{sum}(0,6)\onslide<3->{ = 33}$}
        \onslide<4->{\item $\mathrm{sum}(2,5)\onslide<5->{ = 29}$}
        \onslide<6->{\item $\mathrm{sum}(2,2)\onslide<7->{ = 7}$}
        \vspace{20pt}
        \onslide<8->{\item How do we support these queries efficiently?}
    \ei
\end{frame}

\begin{frame}{Range sum on a static array}
    \bi
        \item Simplification: only support queries of the form $\mathrm{sum}(0, j)$
        \item Notice that $\mathrm{sum}(i,j) = \mathrm{sum}(0,j) - \mathrm{sum}(0,i-1)$
    \ei

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            1 & 0 & \color{vhilight}{7} & \color{vhilight}{8} & \color{vhilight}{5} & \color{vhilight}{9} & 3 \\
            \hline
        \end{tabular}
    \end{center}
    $$=$$
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            \color{vhilight}{1} & \color{vhilight}{0} & \color{vhilight}{7} & \color{vhilight}{8} & \color{vhilight}{5} & \color{vhilight}{9} & 3 \\
            \hline
        \end{tabular}
    \end{center}
    $$-$$
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            \color{vhilight}{1} & \color{vhilight}{0} & 7 & 8 & 5 & 9 & 3 \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{Range sum on a static array}
    \bi
        \item So we're only interested in prefix sums
        \item But there are only $n$ of them...
        \item Just compute them all once in the beginning
    \ei

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            1 & 0 & 7 & 8 & 5 & 9 & 3 \\
            \hline
            \onslide<2->{1} & \onslide<3->{1} & \onslide<4->{8} & \onslide<5->{16} & \onslide<6->{21} & \onslide<7->{30} & \onslide<8->{33} \\
            \hline
        \end{tabular}
    \end{center}

    \bi
        \onslide<9->{\item $O(n)$ time to preprocess}
        \onslide<9->{\item $O(1)$ time each query}

        \vspace{10pt}
        \onslide<9->{\item Can we support updating efficiently? \onslide<10->{No, at least not without modification}}
    \ei
\end{frame}

%\begin{frame}{Example problem: Friends}
%    \bi
%        \item T
%    \ei
%\end{frame}




% TODO: Range queries on a dynamic array
\begin{frame}{Range sum on a dynamic array}
    \bi
        \item What if we want to support:
            \bi
                \item sum over a range
                \item updating an element
            \ei
    \ei

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            \color<2,3,6,7>{vhilight}{1} & \color<2,3,6,7>{vhilight}{0} & \color<2,3,6,7>{vhilight}{7} & \color<2,3,4,5,6,7>{vhilight}{\only<-4>{8}\only<5->{-2}} & \color<2,3,6,7>{vhilight}{5} & \color<2,3,6,7>{vhilight}{9} & \color<2,3,6,7>{vhilight}{3} \\
            \hline
        \end{tabular}
    \end{center}

    \bi
        \onslide<2->{\item $\mathrm{sum}(0,6)\onslide<3->{ = 33}$}
        \onslide<4->{\item $\mathrm{update}(3,-2)$}
        \onslide<6->{\item $\mathrm{sum}(0,6)\onslide<7->{ = 23}$}
        \vspace{20pt}
        \onslide<8->{\item How do we support these queries efficiently?}
    \ei
\end{frame}

\begin{frame}[fragile]{Segment Tree}
            \begin{figure}
                \begin{tikzpicture}[scale=1.8,auto,swap]
                    \onslide<2->{
                        \node[vertex] (0) at (-0.8,0.2) {1};
                        \node[vertex] (1) at (-0.4,0.2) {0};
                        \node[vertex] (2) at (0.0,0.2) {7};
                        \node[vertex] (3) at (0.4,0.2) {8};
                        \node[vertex] (4) at (0.8,0.2) {5};
                        \node[vertex] (5) at (1.2,0.2) {9};
                        \node[vertex] (6) at (1.6,0.2) {3};
                    }

                    \onslide<3->{
                        \node[vertex] (7) at (-0.6,0.7) {1};
                        \node[vertex] (8) at (0.2,0.7) {15};
                        \node[vertex] (9) at (1.0,0.7) {14};
                    }

                    \onslide<4->{
                        \node[vertex] (10) at (-0.2,1.2) {16};
                        \node[vertex] (11) at (1.2,1.2) {17};
                    }

                    \onslide<5->{
                        \node[vertex] (12) at (0.5,2.0) {33};
                    }

                    \onslide<3->{
                        \path[dedge] (7) -- (0);
                        \path[dedge] (7) -- (1);
                        \path[dedge] (8) -- (2);
                        \path[dedge] (8) -- (3);
                        \path[dedge] (9) -- (4);
                        \path[dedge] (9) -- (5);
                    }

                    \onslide<4->{
                        \path[dedge] (10) -- (7);
                        \path[dedge] (10) -- (8);
                        \path[dedge] (11) -- (9);
                        \path[dedge] (11) -- (6);
                    }

                    \onslide<5->{
                        \path[dedge] (12) -- (10);
                        \path[dedge] (12) -- (11);
                    }

                    \pgfresetboundingbox
                    \path [use as bounding box] (0,0) rectangle (0.8,1.8);
                \end{tikzpicture}
            \end{figure}

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
                1 & 0 & 7 & 8 & 5 & 9 & 3 \\
            \hline
        \end{tabular}
    \end{center}

    \bi
        \onslide<6>{\item Each vertex contains the sum of some segment of the array}
    \ei
\end{frame}

\begin{frame}[fragile]{Segment Tree - Code}
    \begin{minted}[fontsize=\scriptsize]{cpp}
struct segment_tree {
    segment_tree *left, *right;
    int from, to, value;
    segment_tree(int from, int to)
        : from(from), to(to), left(NULL), right(NULL), value(0) { }
};

segment_tree* build(const vector<int> &arr, int l, int r) {
    if (l > r) return NULL;
    segment_tree *res = new segment_tree(l, r);
    if (l == r) {
        res->value = arr[l];
    } else {
        int m = (l + r) / 2;
        res->left = build(arr, l, m);
        res->right = build(arr, m + 1, r);
        if (res->left != NULL) res->value += res->left->value;
        if (res->right != NULL) res->value += res->right->value;
    }
    return res;
}
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Querying a Segment Tree}
            \begin{figure}
                \begin{tikzpicture}[scale=1.8,auto,swap]

                    \onslide<-2,4->{
                        \node[vertex] (0) at (-0.8,0.2) {1};
                        \node[vertex] (1) at (-0.4,0.2) {0};
                        \node[vertex] (2) at (0.0,0.2) {7};
                        \node[vertex] (3) at (0.4,0.2) {8};
                        \node[vertex] (4) at (0.8,0.2) {5};
                        \node[vertex] (5) at (1.2,0.2) {9};
                    }
                    \onslide<3>{
                        \node[selected vertex] (0) at (-0.8,0.2) {1};
                        \node[selected vertex] (1) at (-0.4,0.2) {0};
                        \node[selected vertex] (2) at (0.0,0.2) {7};
                        \node[selected vertex] (3) at (0.4,0.2) {8};
                        \node[selected vertex] (4) at (0.8,0.2) {5};
                        \node[selected vertex] (5) at (1.2,0.2) {9};
                    }
                    \node[vertex] (6) at (1.6,0.2) {3};

                    \onslide<-3>{
                        \node[vertex] (7) at (-0.6,0.7) {1};
                        \node[vertex] (8) at (0.2,0.7) {15};
                        \node[vertex] (9) at (1.0,0.7) {14};
                    }
                    \onslide<4>{
                        \node[selected vertex] (7) at (-0.6,0.7) {1};
                        \node[selected vertex] (8) at (0.2,0.7) {15};
                        \node[selected vertex] (9) at (1.0,0.7) {14};
                    }
                    \onslide<5->{
                        \node[vertex] (7) at (-0.6,0.7) {1};
                        \node[vertex] (8) at (0.2,0.7) {15};
                        \node[selected vertex] (9) at (1.0,0.7) {14};
                    }

                    \onslide<-5>{
                        \node[vertex] (10) at (-0.2,1.2) {16};
                    }
                    \onslide<5->{
                        \node[selected vertex] (10) at (-0.2,1.2) {16};
                    }
                    \node[vertex] (11) at (1.2,1.2) {17};

                    \node[vertex] (12) at (0.5,2.0) {33};

                    \path[dedge] (7) -- (0);
                    \path[dedge] (7) -- (1);
                    \path[dedge] (8) -- (2);
                    \path[dedge] (8) -- (3);
                    \path[dedge] (9) -- (4);
                    \path[dedge] (9) -- (5);

                    \path[dedge] (10) -- (7);
                    \path[dedge] (10) -- (8);
                    \path[dedge] (11) -- (9);
                    \path[dedge] (11) -- (6);

                    \path[dedge] (12) -- (10);
                    \path[dedge] (12) -- (11);

                    \pgfresetboundingbox
                    \path [use as bounding box] (0,0) rectangle (0.8,2.0);
                \end{tikzpicture}
            \end{figure}

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            \color<2->{vhilight}{1} & \color<2->{vhilight}{0} & \color<2->{vhilight}{7} & \color<2->{vhilight}{8} & \color<2->{vhilight}{5} & \color<2->{vhilight}{9} & 3 \\
            \hline
        \end{tabular}
    \end{center}

    \bi
        % \item How do we query the tree?
        \onslide<2->{\item $\mathrm{sum}(0,5)\onslide<6->{= 16 + 14 = 30}$}
        \onslide<7->{\item We only need to consider a few vertices to get the entire range}
        \onslide<8->{\item But how do we find them?}
    \ei
\end{frame}

\begin{frame}[fragile]{Querying a Segment Tree}
            \begin{figure}
                \begin{tikzpicture}[scale=1.8,auto,swap]

                    % \onslide<-2,4->{
                        \node[vertex] (0) at (-0.8,0.2) {1};
                        \node[vertex] (1) at (-0.4,0.2) {0};
                        \node[vertex] (2) at (0.0,0.2) {7};
                        \node[vertex] (3) at (0.4,0.2) {8};
                        \node[vertex] (4) at (0.8,0.2) {5};
                        \node[vertex] (5) at (1.2,0.2) {9};
                    % }
                    % \onslide<3>{
                    %     \node[selected vertex] (0) at (-0.8,0.2) {1};
                    %     \node[selected vertex] (1) at (-0.4,0.2) {0};
                    %     \node[selected vertex] (2) at (0.0,0.2) {7};
                    %     \node[selected vertex] (3) at (0.4,0.2) {8};
                    %     \node[selected vertex] (4) at (0.8,0.2) {5};
                    %     \node[selected vertex] (5) at (1.2,0.2) {9};
                    % }
                    \onslide<-4,6->{
                        \node[vertex] (6) at (1.6,0.2) {3};
                    }
                    \onslide<5>{
                        \node[selected vertex] (6) at (1.6,0.2) {3};
                    }

                    % \onslide<-3>{
                        \node[vertex] (7) at (-0.6,0.7) {1};
                        \node[vertex] (8) at (0.2,0.7) {15};
                    \onslide<-4>{
                        \node[vertex] (9) at (1.0,0.7) {14};
                    }
                    \onslide<5->{
                        \node[selected vertex] (9) at (1.0,0.7) {14};
                    }
                    % }
                    % \onslide<4>{
                    %     \node[selected vertex] (7) at (-0.6,0.7) {1};
                    %     \node[selected vertex] (8) at (0.2,0.7) {15};
                    %     \node[selected vertex] (9) at (1.0,0.7) {14};
                    % }
                    % \onslide<5->{
                    %     \node[vertex] (7) at (-0.6,0.7) {1};
                    %     \node[vertex] (8) at (0.2,0.7) {15};
                    %     \node[selected vertex] (9) at (1.0,0.7) {14};
                    % }

                    \onslide<-3>{
                        \node[vertex] (10) at (-0.2,1.2) {16};
                        \node[vertex] (11) at (1.2,1.2) {17};
                    }
                    \onslide<4>{
                        \node[selected vertex] (10) at (-0.2,1.2) {16};
                        \node[selected vertex] (11) at (1.2,1.2) {17};
                    }
                    \onslide<5->{
                        \node[selected vertex] (10) at (-0.2,1.2) {16};
                        \node[vertex] (11) at (1.2,1.2) {17};
                    }

                    \onslide<-2,4->{
                        \node[vertex] (12) at (0.5,2.0) {33};
                    }
                    \onslide<3>{
                        \node[selected vertex] (12) at (0.5,2.0) {33};
                    }

                    \path[dedge] (7) -- (0);
                    \path[dedge] (7) -- (1);
                    \path[dedge] (8) -- (2);
                    \path[dedge] (8) -- (3);
                    \path[dedge] (9) -- (4);
                    \path[dedge] (9) -- (5);

                    \path[dedge] (10) -- (7);
                    \path[dedge] (10) -- (8);
                    \path[dedge] (11) -- (9);
                    \path[dedge] (11) -- (6);

                    \path[dedge] (12) -- (10);
                    \path[dedge] (12) -- (11);

                    \pgfresetboundingbox
                    \path [use as bounding box] (0,0) rectangle (0.8,2.0);
                \end{tikzpicture}
            \end{figure}

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            \color<2->{vhilight}{1} & \color<2->{vhilight}{0} & \color<2->{vhilight}{7} & \color<2->{vhilight}{8} & \color<2->{vhilight}{5} & \color<2->{vhilight}{9} & 3 \\
            \hline
        \end{tabular}
    \end{center}

    \bi
        \item $\mathrm{sum}(0,5)$
    \ei
\end{frame}

\begin{frame}[fragile]{Querying a Segment Tree - Code}
    \vspace{50pt}
    \begin{minted}[fontsize=\scriptsize]{cpp}
int query(segment_tree *tree, int l, int r) {
    if (tree == NULL) return 0;
    if (l <= tree->from && tree->to <= r) return tree->value;
    if (tree->to < l) return 0;
    if (r < tree->from) return 0;
    return query(tree->left, l, r) + query(tree->right, l, r);
}
    \end{minted}
\end{frame}


\begin{frame}[fragile]{Updating a Segment Tree}
    \begin{figure}
        \begin{tikzpicture}[scale=1.8,auto,swap]
            \node[vertex] (0) at (-0.8,0.2) {1};
            \node[vertex] (1) at (-0.4,0.2) {0};
            \node[vertex] (2) at (0.0,0.2) {7};
            \onslide<-2>{
                \node[vertex] (3) at (0.4,0.2) {8};
            }
            \onslide<3>{
                \node[selected vertex] (3) at (0.4,0.2) {8};
            }
            \onslide<4>{
                \node[selected vertex] (3) at (0.4,0.2) {5};
            }
            \onslide<5->{
                \node[vertex] (3) at (0.4,0.2) {5};
            }
            \node[vertex] (4) at (0.8,0.2) {5};
            \node[vertex] (5) at (1.2,0.2) {9};
            \node[vertex] (6) at (1.6,0.2) {3};

            \node[vertex] (7) at (-0.6,0.7) {1};
            \onslide<-4>{
                \node[vertex] (8) at (0.2,0.7) {15};
            }
            \onslide<5>{
                \node[selected vertex] (8) at (0.2,0.7) {15};
            }
            \onslide<6>{
                \node[selected vertex] (8) at (0.2,0.7) {12};
            }
            \onslide<7->{
                \node[vertex] (8) at (0.2,0.7) {12};
            }
            \node[vertex] (9) at (1.0,0.7) {14};

            \onslide<-6>{
                \node[vertex] (10) at (-0.2,1.2) {16};
            }
            \onslide<7>{
                \node[selected vertex] (10) at (-0.2,1.2) {16};
            }
            \onslide<8>{
                \node[selected vertex] (10) at (-0.2,1.2) {13};
            }
            \onslide<9->{
                \node[vertex] (10) at (-0.2,1.2) {13};
            }
            \node[vertex] (11) at (1.2,1.2) {17};

            \onslide<-8>{
                \node[vertex] (12) at (0.5,2.0) {33};
            }
            \onslide<9>{
                \node[selected vertex] (12) at (0.5,2.0) {33};
            }
            \onslide<10>{
                \node[selected vertex] (12) at (0.5,2.0) {30};
            }
            \onslide<11->{
                \node[vertex] (12) at (0.5,2.0) {30};
            }

            \path[dedge] (7) -- (0);
            \path[dedge] (7) -- (1);
            \path[dedge] (8) -- (2);
            \path[dedge] (8) -- (3);
            \path[dedge] (9) -- (4);
            \path[dedge] (9) -- (5);

            \path[dedge] (10) -- (7);
            \path[dedge] (10) -- (8);
            \path[dedge] (11) -- (9);
            \path[dedge] (11) -- (6);

            \path[dedge] (12) -- (10);
            \path[dedge] (12) -- (11);

            \pgfresetboundingbox
            \path [use as bounding box] (0,0) rectangle (0.8,2.0);
        \end{tikzpicture}
    \end{figure}

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            1 & 0 & 7 & \color<3->{vhilight}{\only<-3>{8}\only<4->{5}} & 5 & 9 & 3 \\
            \hline
        \end{tabular}
    \end{center}

    \bi
        \onslide<2->{\item $update(3, 5)$}
    \ei
\end{frame}

\begin{frame}[fragile]{Updating a Segment Tree - Code}
    \vspace{40pt}
    \begin{minted}[fontsize=\scriptsize]{cpp}
int update(segment_tree *tree, int i, int val) {
    if (tree == NULL) return 0;
    if (tree->to < i) return tree->value;
    if (i < tree->from) return tree->value;
    if (tree->from == tree->to && tree->from == i) {
        tree->value = val;
    } else {
        tree->value = update(tree->left, i, val) + update(tree->right, i, val);
    }
    return tree->value;
}
    \end{minted}
\end{frame}

\begin{frame}{Segment Tree}
    \bi
        \item Now we can
            \bi
        \item build a Segment Tree\onslide<3->{ in {\color{hilight}{$O(n)$}}}
        \item query a range\onslide<4->{ in {\color{hilight}{$O(\log n)$}}}
        \item update a single value\onslide<5->{ in {\color{hilight}{$O(\log n)$}}}
            \ei
        \onslide<2->{\item But how efficient are these operations?}
        \vspace{20pt}
        \onslide<6->{\item Trivial to use Segment Trees for $\min$, $\max$, $\gcd$, and other similar operators, basically the same code}
		\item<7-> How do we add a value $a$ to all cells \emph{between} $i$ and $j$? \\ \visible<8->{Just iterating gives $\mathcal O(n \log n)$}
    \ei
\end{frame}



\begin{frame}[fragile]{Range-Updates in a Segment Tree}
    \begin{figure}
        \begin{tikzpicture}[scale=2.4,auto,swap]
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node[vertex] (0) at (-0.8,0.2) {1+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node<1>[vertex] (1) at (-0.4,0.2) {0+0};
            \node<2-3>[selected vertex] (1) at (-0.4,0.2) {0+0};
            \node<4>[selected vertex] (1) at (-0.4,0.2) {0+2};
            \node<5->[vertex] (1) at (-0.4,0.2) {0+2};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node[vertex] (2) at (0.0,0.2) {2+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node[vertex] (3) at (0.4,0.2) {4+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node[vertex] (4) at (0.8,0.2) {5+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node[vertex] (5) at (1.2,0.2) {7+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node<-7>[vertex] (6) at (1.6,0.2) {3+0};
            \node<8->[vertex] (6) at (1.6,0.2) {5+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node<1-2>[vertex] (7) at (-0.6,0.7) {1+0};
            \node<3->[vertex] (7) at (-0.6,0.7) {3+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node<1>[vertex] (8) at (0.2,0.7) {6+0};
            \node<2-3>[selected vertex] (8) at (0.2,0.7) {6+0};
            \node<4>[selected vertex] (8) at (0.2,0.7) {6+2};
            \node<5-7>[vertex] (8) at (0.2,0.7) {6+2};
            \node<8>[selected vertex] (8) at (0.2,0.7) {6+2};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node<-7>[vertex] (9) at (1.0,0.7) {12+0};
            \node<8->[selected vertex] (9) at (1.0,0.7) {12+2};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node<1-2>[vertex] (10) at (-0.2,1.2) {7+0};
            \node<3-6>[vertex] (10) at (-0.2,1.2) {13+0};
            \node<7>[selected vertex] (10) at (-0.2,1.2) {13+0};
            \node<8>[vertex] (10) at (-0.2,1.2) {13+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node<1>[vertex] (11) at (1.2,1.2) {15+0};
            \node<2-3>[selected vertex] (11) at (1.2,1.2) {15+0};
            \node<4>[selected vertex] (11) at (1.2,1.2) {15+2};
            \node<5-6>[vertex] (11) at (1.2,1.2) {15+2};
            \node<7>[selected vertex] (11) at (1.2,1.2) {15+2};
            \node<8->[vertex] (11) at (1.2,1.2) {21+0};
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \node<1-2>[vertex] (12) at (0.5,2.0) {22+0};
            \node<3-5>[vertex] (12) at (0.5,2.0) {34+0};
            \node<6>[selected vertex] (12) at (0.5,2.0) {34+0};
            \node<7->[vertex] (12) at (0.5,2.0) {34+0};

            \path[dedge] (7) -- (0);
            \path[dedge] (7) -- (1);
            \path[dedge] (8) -- (2);
            \path[dedge] (8) -- (3);
            \path[dedge] (9) -- (4);
            \path[dedge] (9) -- (5);

            \path[dedge] (10) -- (7);
            \path[dedge] (10) -- (8);
            \path[dedge] (11) -- (9);
            \path[dedge] (11) -- (6);

            \path[dedge] (12) -- (10);
            \path[dedge] (12) -- (11);

            \pgfresetboundingbox
            \path [use as bounding box] (0,0) rectangle (0.8,2.0);
        \end{tikzpicture}
    \end{figure}

    \begin{center}
		\setlength{\tabcolsep}{10pt}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
				1 &
				\color<2-4>{vhilight}{\only<1-3>{0}\only<4->{2}} &
				\color<2->{vhilight}{\only<1-3>{2}\only<4->{4}} &
				\color<2->{vhilight}{\only<1-3>{4}\only<4->{6}} &
				\color<2->{vhilight}{\only<1-3>{5}\only<4->{7}} &
				\color<2->{vhilight}{\only<1-3>{7}\only<4->{9}} &
				\color<2-4>{vhilight}{\only<1-3>{3}\only<4->{5}} \\ 
            \hline
        \end{tabular}
    \end{center}

    \bi
		\item \only<1-4>{$\mathrm{addRange}(2, 1, 6)$} \only<5->{$\mathrm{sum}(2,5)$}\only<8>{$=26$}
    \ei
\end{frame}


% \begin{frame}{Example problem: Potentiometers}
%     \bi
%         \item http://uva.onlinejudge.org/external/120/12086.html
%     \ei
% \end{frame}

\begin{frame}{Segment Tree}
    It's pretty complicated to implement isn't it?\\
    \begin{figure}
        \begin{tikzpicture}[scale=1.8,auto,swap]
            \node[vertex] (0) at (-0.8,0.2) {1};
            \onslide<-1>{\node[vertex] (1) at (-0.4,0.2) {0};}
            \onslide<2->{\node[selected vertex] (1) at (-0.4,0.2) {0};}
            \node[vertex] (2) at (0.0,0.2) {7};
            \onslide<-1>{\node[vertex] (3) at (0.4,0.2) {8};}
            \onslide<2->{\node[selected vertex] (3) at (0.4,0.2) {8};}
            \node[vertex] (4) at (0.8,0.2) {5};
            \onslide<-1>{\node[vertex] (5) at (1.2,0.2) {9};}
            \onslide<2->{\node[selected vertex] (5) at (1.2,0.2) {9};}
            \onslide<-1>{\node[vertex] (6) at (1.6,0.2) {3};}
            \onslide<2->{\node[selected vertex] (6) at (1.6,0.2) {3};}

            \node[vertex] (7) at (-0.6,0.7) {1};
            \onslide<-1>{\node[vertex] (8) at (0.2,0.7) {15};}
            \onslide<2->{\node[selected vertex] (8) at (0.2,0.7) {15};}
            \node[vertex] (9) at (1.0,0.7) {14};

            \node[vertex] (10) at (-0.2,1.2) {16};
            \onslide<-1>{\node[vertex] (11) at (1.2,1.2) {17};}
            \onslide<2->{\node[selected vertex] (11) at (1.2,1.2) {17};}

            \node[vertex] (12) at (0.5,2.0) {33};

            \path[dedge] (7) -- (0);
            \path[dedge] (7) -- (1);
            \path[dedge] (8) -- (2);
            \path[dedge] (8) -- (3);
            \path[dedge] (9) -- (4);
            \path[dedge] (9) -- (5);

            \path[dedge] (10) -- (7);
            \path[dedge] (10) -- (8);
            \path[dedge] (11) -- (9);
            \path[dedge] (11) -- (6);

            \path[dedge] (12) -- (10);
            \path[dedge] (12) -- (11);

            \pgfresetboundingbox
            \path [use as bounding box] (0,0) rectangle (0.8,2.0);
        \end{tikzpicture}
    \end{figure}
    \bi
        \item For $sum$ some numbers are \textbf{redundant}\\
        \item For every node only the left successor is relevant
    \ei
\end{frame}


\begin{frame}[fragile]{Fenwick Trees}
    \bi
        \item Sum Segment Tree represented by an array of size $n$
        \item assume range is $1\dots n$
        \item use function $LSOne(x) = $\texttt{x\&(-x)} which returns the \textbf{value} of the least significant bit of $x$
	\bi
	  \item $LSOne(5) = 1$
	  \item $LSOne(12) = 4$
	  \item $LSOne(2n+1) = 1$
	  \item $LSOne(2^n) = 2^n$
	\ei
	\item construct $ft[x] = \sum_{i=x-LSOne(x)+1}^x A[i]$
    \ei
\end{frame}


\begin{frame}[fragile]{Fenwick Trees}
    $ft[x] = \sum_{i=x-LSOne(x)+1}^x A[i]$\\[\baselineskip]
    \begin{tikzpicture}[scale=1.8,auto,swap,
    array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=white!30},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
% row 0/.style={nodes={draw=none, fill=none, minimum size=5mm}},
% row 1 column 1/.style={nodes={draw}}
    }]
      \matrix[array] (array) {
      1 & 1 & 7 & 16 & 5 & 14 & 3\\
      1 & 0 & 7 & \phantom{1}8 & 5 & \phantom{1}9 & 3\\ };
      %\node[draw, fill=gray, minimum size=4mm] at (array-2-2) (box) {};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-1)+(0,1)$) (el1) {1};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-2)+(0,1.5)$) (el2) {1};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-3)+(0,1)$) (el3) {7};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-4)+(0,2)$) (el4) {16};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-5)+(0,1)$) (el5) {5};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-6)+(0,1.5)$) (el6) {14};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-7)+(0,1)$) (el7) {3};

      \begin{pgfonlayer}{bg}
	  \draw[fill=black] ($(el1) + (-0.1,0.575)$) rectangle ($(el2) - (0,0.075)$);
	  \draw[fill=black] ($(el1) + (-0.1,1.075)$) rectangle ($(el4) - (0,0.075)$);
	  \draw[fill=black] ($(el5) + (-0.1,0.575)$) rectangle ($(el6) - (0,0.075)$);
      \end{pgfonlayer}
    \end{tikzpicture}
\end{frame}


\begin{frame}[fragile]{Querying Fenwick Trees}
    $ft[x] = \sum_{i=x-LSOne(x)+1}^x A[i]$\\[\baselineskip]
    \begin{tikzpicture}[scale=1.8,auto,swap,
    array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=white!30},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
% row 0/.style={nodes={draw=none, fill=none, minimum size=5mm}},
% row 1 column 1/.style={nodes={draw}}
    }]
      \matrix[array] (array) {
      1 & 1 & 7 & 16 & 5 & 14 & 3\\
      \textcolor{vhilight} 1 & \textcolor{vhilight}0 & \textcolor{vhilight}7 & \phantom{1}\textcolor{vhilight}8 & \textcolor{vhilight}5 & \phantom{1}\textcolor{vhilight}9 & 3\\ };
      %\node[draw, fill=gray, minimum size=4mm] at (array-2-2) (box) {};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-1)+(0,1)$) (el1) {1};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-2)+(0,1.5)$) (el2) {1};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-3)+(0,1)$) (el3) {7};
      \onslide<-2>{\node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-4)+(0,2)$) (el4) {16};}
      \onslide<3->{\node[draw, circle, fill=vhilight!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-4)+(0,2)$) (el4) {\textcolor{vhilight}{16}};}
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-5)+(0,1)$) (el5) {5};
      \onslide<-1>{\node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-6)+(0,1.5)$) (el6) {14};}
      \onslide<2->{\node[draw, circle, fill=vhilight!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-6)+(0,1.5)$) (el6) {\textcolor{vhilight}{14}};}
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-7)+(0,1)$) (el7) {3};

      \begin{pgfonlayer}{bg}
	  \draw[fill=black] ($(el1) + (-0.1,0.575)$) rectangle ($(el2) - (0,0.075)$);
	  \onslide<-2>{\draw[fill=black] ($(el1) + (-0.1,1.075)$) rectangle ($(el4) - (0,0.075)$);}
	  \onslide<3->{\draw[fill=vhilight] ($(el1) + (-0.1,1.075)$) rectangle ($(el4) - (0,0.075)$);}
	  \onslide<-1>{\draw[fill=black] ($(el5) + (-0.1,0.575)$) rectangle ($(el6) - (0,0.075)$);}
	  \onslide<2->{\draw[fill=vhilight] ($(el5) + (-0.1,0.575)$) rectangle ($(el6) - (0,0.075)$);}
      \end{pgfonlayer}
    \end{tikzpicture}
    \bi
      \item $\mathrm{sum}(6) = $ \onslide<2->{\texttt{ft[4]}} \onslide<3->{$+$ \texttt{ft[6]}}
      \item<4-> $\mathrm{sum}(x) = ft[x] + \mathrm{sum}(x - LSOne(x))$ 
      \item<4-> $\mathrm{sum}(0) = 0$ 
    \ei
\end{frame}

\begin{frame}[fragile]{Updating Fenwick Trees}
    $ft[x] = \sum_{i=x-LSOne(x)+1}^x A[i]$\\[\baselineskip]
    \begin{tikzpicture}[scale=1.8,auto,swap,
    array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=white!30},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
% row 0/.style={nodes={draw=none, fill=none, minimum size=5mm}},
% row 1 column 1/.style={nodes={draw}}
    }]
      \matrix[array] (array) {
      1 & 1 & 7 & 16 & 5 & 14 & 3\\
      \textcolor{vhilight} 1 & \textcolor{vhilight}0 & \only<1>{\textcolor{vhilight}7}\only<2->{\textcolor{vhilight}5} & \phantom{1}\textcolor{vhilight}8 & \textcolor{vhilight}5 & \phantom{1}\textcolor{vhilight}9 & 3\\ };
      %\node[draw, fill=gray, minimum size=4mm] at (array-2-2) (box) {};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-1)+(0,1)$) (el1) {1};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-2)+(0,1.5)$) (el2) {1};
      \onslide<-2>{\node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-3)+(0,1)$) (el3) {7};}
      \onslide<3->{\node[draw, circle, fill=vhilight!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-3)+(0,1)$) (el3) {\textcolor{vhilight}5};}
      \onslide<-3>{\node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-4)+(0,2)$) (el4) {16};}
      \onslide<4->{\node[draw, circle, fill=vhilight!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-4)+(0,2)$) (el4) {\textcolor{vhilight}{14}};}
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-5)+(0,1)$) (el5) {5};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-6)+(0,1.5)$) (el6) {14};
      \node[draw, circle, fill=gray!30, inner sep=0.06cm, minimum size=1mm] at ($(array-2-7)+(0,1)$) (el7) {3};

      \begin{pgfonlayer}{bg}
	  \draw[fill=black] ($(el1) + (-0.1,0.575)$) rectangle ($(el2) - (0,0.075)$);
	  \draw[fill=black] ($(el1) + (-0.1,1.075)$) rectangle ($(el4) - (0,0.075)$);
	  \draw[fill=black] ($(el5) + (-0.1,0.575)$) rectangle ($(el6) - (0,0.075)$);
      \end{pgfonlayer}
    \end{tikzpicture}
    \bi
      \item $\mathrm{add}(3,-2)$
    \ei
\end{frame}

\begin{frame}[fragile]{Fenwick Trees - Code}
%     \vspace{-20pt}
    \begin{minted}[fontsize=\scriptsize]{cpp}
int fwt_size, bi_tree[MAXN];

void clear(int size) {
    memset(bi_tree, 0, sizeof(int) * size); fwt_size = size;
}
void add(int pos, int val) {
    if (!pos) {
        bi_tree[0] = bi_tree[0] + val;
        return;
    }
    while (pos < fwt_size) {
        bi_tree[pos] = bi_tree[pos] + val;
        pos += pos & (-pos);
    }
}
int rank(int pos) {
    if (pos < 0) return 0;
    int res = bi_tree[0];
    while (pos) {
        res = res + bi_tree[pos];
        pos &= pos - 1;
    }
    return res;
}
    \end{minted}
\end{frame}

\begin{frame}{Fenwick Trees}
    \bi
        \item Lightweight implementation of Sum Segment Tree
        \bi
	  \item build a Fenwick Tree\onslide<2->{ in {\color{hilight}{$O(n)$}}}
	  \item query a range\onslide<3->{ in {\color{hilight}{$O(\log n)$}}}
	  \item update a single value\onslide<4->{ in {\color{hilight}{$O(\log n)$}}}
	\ei
    \ei
\end{frame}

\end{document}
