\documentclass[12pt,t]{beamer}
\subtitle{10 -- Geometry}
\newcommand{\shorttitle}{Geometry}
\input{../acmlecture.tex}


\begin{frame}<beamer>{Today we're going to cover}
    \vspace{40pt}
    %\tableofcontents[hideallsubsections]
    \bi
      \item Geometry
      \item Computational geometry
	  \bi
	      \item 2D-Geometry
		  \item 3D (similar just with one more dimension)
	  \ei
    \ei
\end{frame}

\section{Geometry}
\subsection{Points and vectors}

\begin{frame}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{figure}
        \begin{tikzpicture}
          \draw[step=.5cm, very thin, foreground, opacity=0.2] (0,0) grid (5,5);
          \draw[thick, ->] (1,1) -- (0,1);
          \draw[thick, ->] (1,1) -- (5,1);
          \draw[thick, ->] (1,1) -- (1,0);
          \draw[thick, ->] (1,1) -- (1,5);

          \visible<2->{
            \draw[hilight,fill] (3,4) circle[radius=2pt];
            \draw (3,4) node[anchor=north west] {\scriptsize$(3,6)$};
            \draw[hilight,fill] (4,2.5) circle[radius=2pt];
            \draw (4,2.5) node[anchor=north west] {\scriptsize$(6,3)$};
            \draw[hilight,fill] (1.5,2.5) circle[radius=2pt];
            \draw (1.5,2.5) node[anchor=south] {\scriptsize$(1,3)$};
          }

          \visible<3->{
            \draw[hilight,thick,->] (1,1) -- (3,4);
            \draw[hilight,thick,->] (1,1) -- (4,2.5);
            \draw[hilight,thick,->] (1,1) -- (1.5,2.5);
          }
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
        \onslide<2->
        \item Points are represented by a pair of numbers, $(x,y)$.
        \onslide<3->
        \item Vectors are represented in the same way.
        \item Thinking of points as vectors is quite usefull.
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  %Points and vectors can be represented by a pair of numbers, $x$ and $y$.
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{figure}
        \footnotesize
        \begin{tikzpicture}
          \draw[step=.5cm, very thin, foreground, opacity=0.2] (0,0) grid (5,5);
          \draw[thick, ->] (1,1) -- (0,1);
          \draw[thick, ->] (1,1) -- (5,1);
          \draw[thick, ->] (1,1) -- (1,0);
          \draw[thick, ->] (1,1) -- (1,5);

          \draw[hilight,fill] (4,3) circle[radius=2pt];
          \draw[title,fill] (1.5,2.5) circle[radius=2pt];

          \draw[hilight,thick,->] (1,1) -- node[right=3pt, near end] {$\vec u$} (4,3);
          \draw[title,thick,->] (1,1) -- node[left=-2pt,near end] {$\vec v$} (1.5,2.5);

          \visible<3>{
            \draw[vhilight,fill] (4.5,4.5) circle[radius=2pt];
            \draw[hilight,thick,opacity=0.4] (1.5,2.5) -- (4.5, 4.5);
            \draw[title,thick,opacity=0.4] (4,3) -- (4.5, 4.5);
            \draw[vhilight,thick,->] (1,1) -- node[left=10pt, near end] {$\vec u + \vec v$} (4.5, 4.5);
          }
          \visible<5>{
            \draw[title,thick,->, opacity=0.7] (4,3) -- (3.5,1.5);
            \draw[vhilight,fill] (3.5,1.5) circle[radius=2pt];
            \draw (3.5,1.5) node[right=4pt] {{\color{vhilight}$\vec u - \vec v$}};
            \draw[vhilight,thick,->] (1,1) --  (3.5, 1.5);
            \draw[vhilight,thick,->, opacity=0.5] (1.5,2.5) -- (4,3);
          }
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.5\textwidth}
      %\footnotesize
      \bi
        \onslide<2->
        \item Simplest operation, addition is defined as
          \[
            {\color{title!50}
            \begin{pmatrix}
              x_0 \\
              y_0
            \end{pmatrix}
            }
            +
            {\color{hilight!50}
            \begin{pmatrix}
              x_1 \\
              y_1
            \end{pmatrix}
            }
            =
            {\color{vhilight!50}
            \begin{pmatrix}
              x_0 + x_1 \\
              y_0 + y_1
            \end{pmatrix}
            }
          \]
        \onslide<4->
        \item Subtraction is defined in the same manner
          \[
            {\color{hilight!50}
            \begin{pmatrix}
              x_0 \\
              y_0
            \end{pmatrix}
            }
            -
            {\color{title!50}
            \begin{pmatrix}
              x_1 \\
              y_1
            \end{pmatrix}
            }
            =
            {\color{vhilight!50}
            \begin{pmatrix}
              x_0 - x_1 \\
              y_0 - y_1
            \end{pmatrix}
            }
          \]
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{cpp}
typedef double coord;
struct pt{
    coord x,y;
    pt():x(0),y(0){};
    pt(coord _x,coord _y):x(_x),y(_y){};
    pt operator+(const pt& p) {
        return pt(x+p.x,y+p.y);
    }
    pt operator-(const pt& p) {
        return pt(x-p.x,y-p.y);
    }
    coord operator*(const pt& p) {
        return x*p.x+y*p.y;
    }
};
double len(pt p) { return sqrt(double(p*p)); }
  \end{minted}
\end{frame}

\begin{frame}{Integer-safety}
	\bi
		\item Geometry(-operations) can be grouped into two groups
		\bi
			\item exact on integers
			\item always needs floating-point calculations
		\ei
		\item<2-> Many Geometry problems require exact results
		\bi
			\item<3-> Testcases are designed to fail on floating-point solutions
			\item<4-> ... remember \texttt{long double}?
		\ei
	\ei
		\visible<3->{
	\includegraphics[width = 0.35\textwidth]{figures/27-rotated-dfstree.png} \quad
	\includegraphics[width = 0.45\textwidth]{figures/wf16.png}
		}
\end{frame}

\begin{frame}[fragile]
  \bi
  	\item Points and vectors can also be represented by \emph{polar coordinates}
  	$(r,\phi)$
  	\bi
  		\item $r$ -- distance of the point from $(0,0)$
  		\item $\phi$ -- angle of the point from the positive x-axis
  	\ei
  	\item computing $r$ is easy -- \texttt{len(x)}
  	\item what abount $\phi$? \pause
  	\[\phi = \begin{cases}
  			\arctan \frac{y}{x} &\text{für } x > 0 \\
  			\arctan \frac{y}{x} + \pi &\text{für } x < 0, y \geq 0 \\
  			\arctan \frac{y}{x} -\pi &\text{für } x > 0, y < 0\\
  			\frac{\pi}{2} &\text{für } x = 0, y > 0 \\
  			-\frac{\pi}{2} &\text{für } x = 0, y < 0 \\
  			0 &\text{für } x = 0, y = 0 \\
  		\end{cases}\]
  		\pause
  	\item $\phi = \texttt{atan2}(x,y)$
  \ei
\end{frame}

\begin{frame}[fragile]
  \vspace{20pt}
  \ldots or we could use the \texttt{complex<double>} class.
  \begin{minted}{cpp}
typedef complex<double> point;
  \end{minted}
  \onslide<2->
  \vspace{10pt}
  The \texttt{complex} class in \texttt{C++} and \texttt{Java} has methods defined for
  \bi
    \item Addition
    \item Subtraction
    \item Multiplication by a scalar
    \item Length
    \item Trigonometric functions
  \ei
\end{frame}

\begin{frame}[fragile]
  \vspace{20pt}
  Complex numbers have the real part and the imaginary part. Can be thought of
  as vectors or points on the complex plane.
  \bi
    \onslide<2->
    \item \mintinline{cpp}{double real(p)} returns the real part, or in our case, the $x$ value
      of \mintinline{cpp}{p}
    \onslide<3->
    \item \mintinline{cpp}{double imag(p)} returns the imaginary part, $y$ value of \mintinline{cpp}{p}.
    \onslide<4->
    \item \mintinline{cpp}{double abs(p)} returns the absolute value of the complex number, the
      length of the vector.
    \onslide<5->
    \item \mintinline{cpp}{double sin(p)}, \mintinline{cpp}{double cos(p)}, \mintinline{cpp}{double tan(p)}, trigonometric
      functions.
  \ei
\end{frame}

\subsection{Dot product}
\begin{frame}
  \vspace{20pt}
  Given two vectors 
  \[
    \vec{u} = \begin{pmatrix} x_0 \\ y_0 \end{pmatrix} \quad\quad
    \vec{v} = \begin{pmatrix} x_1 \\ y_1 \end{pmatrix}
  \]
  the dot product of $\vec{u}$ and $\vec{v}$ is defined as 
  \[
    \begin{pmatrix} x_0 \\ y_0 \end{pmatrix} \cdot
    \begin{pmatrix} x_1 \\ y_1 \end{pmatrix} = 
    x_0 \cdot x_1 + y_0 \cdot y_1
  \]
  \onslide<2->
  Which in geometric terms is
  \[
    \vec{u} \cdot \vec{v} = 
    \lvert \vec{u} \rvert \lvert \vec{v} \rvert \cos \theta
  \]
\end{frame}

%\begin{frame}
  %\begin{columns}
    %\begin{column}{0.4\textwidth}
      %\vspace{20pt}
      %\begin{figure}
        %\begin{tikzpicture}
          %\draw[fill=title!50] (0,0) -- (40:.75cm) arc (40:0:.75cm);
          %\draw[->,thick,hilight] (0,0) -- node[near end, below] {$\vec u$} (0:4cm);
          %\draw[->,thick,vhilight] (0,0) -- node[near end, left=4pt] {$\vec v$} (40:3.2cm);
          %\draw(22:0.5cm) node {\color{background}$\theta$};

          %\visible<2->{
            %\draw[dashed] (40:3.2cm) -- (0:2.45134221cm);
            %\draw[title,thick,->] (0,0) -- node[below] {$\vec{v}_{\vec{u}}$} (0:2.45134221cm);
          %}
        %\end{tikzpicture}
      %\end{figure}
    %\end{column}
    %\begin{column}{0.6\textwidth}
      %\bi
        %\item Allows us to calculate the angle between $\vec u$ and $\vec v$.
          %\[
            %\theta = \arccos\left(\frac{\vec{u} \cdot \vec{v}}{\lvert \vec u \rvert \lvert \vec v \rvert}\right)
          %\]
        %\onslide<2->
        %\item And the projection of $\vec v$ onto $\vec u$.
          %\[
            %\vec{v}_{\vec{u}} = \left(\frac{\vec{u}\cdot\vec{v}}{\lvert u \rvert}\right) \vec{u}
          %\]
      %\ei
    %\end{column}
  %\end{columns}
%\end{frame}

\begin{frame}
  \begin{columns}
    \begin{column}{0.4\textwidth}
      \vspace{20pt}
      \begin{figure}
        \begin{tikzpicture}
          \draw[fill=title!50] (0,0) -- (40:.75cm) arc (40:0:.75cm);
          \draw[->,thick,hilight] (0,0) -- node[near end, below] {$\vec u$} (0:4cm);
          \draw[->,thick,vhilight] (0,0) -- node[near end, left=4pt] {$\vec v$} (40:3.2cm);
          \draw(22:0.5cm) node {\color{background}$\theta$};

          \visible<2->{
            \draw[dashed] (40:3.2cm) -- (0:2.45134221cm);
            \draw[title,thick,->] (0,0) -- node[below] {$\vec{v}_{\vec{u}}$} (0:2.45134221cm);
          }

          \visible<3->{
            \draw (40:3.2cm) node[above] {$p$};
            \draw[fill,vhilight] (40:3.2cm) circle[radius=2pt];
            \draw (0:2.45134221cm) node[above right] {$q$};
            \draw[fill,title] (0:2.45134221cm) circle[radius=2pt];
          }
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.6\textwidth}
      \bi
        \only<1-2>{
          \item Allows us to calculate the angle between $\vec u$ and $\vec v$.
            \[
              \theta = \arccos\left(\frac{\vec{u} \cdot \vec{v}}{\lvert \vec u \rvert \lvert \vec v \rvert}\right)
            \]
        }
        \only<2>{
          \item And the projection of $\vec v$ onto $\vec u$.
            \[
              \vec{v}_{\vec{u}} = \left(\frac{\vec{u}\cdot\vec{v}}{\lvert \vec u \rvert}\right) \vec{u}
            \]
        }
        \only<3->{
          \vspace{20pt}
          \item The closest point on $\vec{u}$ to $p$ is $q$.
        }
        \only<4->{
          \item The distance from $p$ to $\vec{u}$ is the distance from $p$ to $q$.
        }
%        \only<5->{
%          \item Unless $q$ is outside $\vec{u}$, then the closest point is either of the endpoints.
%        }
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \vspace{20pt}
%   Rest of the code will use the \texttt{complex} class.
%   \footnotesize
  \begin{minted}{cpp}
pt closestpt(pt a0, pt a1, pt p) {
    pt d=a1-a0;
    return a0+(d*(d*(p-a0))/(d*d));
}
  \end{minted} 
  \bi
	\item<2-> Is \texttt{closestpt(a,b,c)} always on $\overline{ab}$? \only<3->{\quad \textbf{No!}}
	\ei
		\begin{overprint}
\onslide<4->
				\begin{minted}{cpp}
pt closestpt(pt a0, pt a1, pt p) {
    if ((a1 - a0) * (p - a1) > 0) return a1;
    if ((a0 - a1) * (p - a0) > 0) return a0;
    pt d=a1-a0;
    return a0+(d*(d*(p-a0))/(d*d));
}
		\end{minted}
		\end{overprint}
  \bi
	\item<5-> \textbf{Not} integer-safe
  \ei
\end{frame}
\subsection{Cross product}
\begin{frame}
  \vspace{20pt}
  Given two vectors
  \[
    \vec{u} = \begin{pmatrix} x_0 \\ y_0 \end{pmatrix} \quad\quad
    \vec{v} = \begin{pmatrix} x_1 \\ y_1 \end{pmatrix}
  \]
  the cross product of $\vec{u}$ and $\vec{v}$ is defined as 
  \[
    \left\lvert \begin{pmatrix} x_0 \\ y_0 \end{pmatrix} \times
    \begin{pmatrix} x_1 \\ y_1 \end{pmatrix}\right\rvert  = 
    x_0\cdot y_1 - y_0 \cdot x_1
  \]
  \onslide<2->
  Which in geometric terms is
  \[
    \lvert \vec{u} \times \vec{v} \vert = 
    \lvert \vec{u} \rvert \lvert \vec{v} \rvert \sin \theta
  \]
\end{frame}

\begin{frame}
  \begin{columns}
    \begin{column}{0.4\textwidth}
      \vspace{20pt}
      \begin{figure}
        \begin{tikzpicture}
          \coordinate (A) at (0,0);
          \coordinate (B) at (0:3cm);
          \coordinate (D) at (60:2.7cm);
          \coordinate (C) at ($ (B) + (D) $);

          \tkzDrawPolygon[color=foreground](A,B,C,D);
          \draw[fill=title!50] (0,0) -- (60:.75cm) arc (60:0:.75cm);
          \draw[->,thick,hilight] (0,0) -- node[near end, below] {$\vec u$} (B);
          \draw[->,thick,vhilight] (0,0) -- node[near end, left=4pt] {$\vec v$} (D);
          \draw(30:0.5cm) node {\color{background}$\theta$};

          \visible<2->{
            %\draw[title,thick,->] (0,0) -- node[below] {$\vec{v}_{\vec{u}}$} (0:2.45134221cm);
            \tkzDrawPolygon[fill=title,opacity=0.4](A,B,D);
            \draw (20:1.6cm) node {\color{background}$\frac{1}{2}\lvert \vec{u} \times \vec{v} \rvert$};
            \draw[->,thick,hilight] (0,0) -- node[near end, below] {$\vec u$} (B);
            \draw[->,thick,vhilight] (0,0) -- node[near end, left=4pt] {$\vec v$} (D);
            \draw[fill=title!50] (0,0) -- (60:.75cm) arc (60:0:.75cm);
            \draw(30:0.5cm) node {\color{background}$\theta$};
          }
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.6\textwidth}
      \bi
        \item Allows us to calculate the area of the triangle formed by $\vec u$ and $\vec v$.
          \[
            \frac{\lvert \vec{u} \times \vec{v} \rvert}{2}
          \]
        \onslide<3->
        \item And can tell us if the angle between $\vec u$ and $\vec v$ is positive or negative.
          \begin{align*}
            \lvert \vec{u} \times \vec{v} \rvert &< 0 \quad\text{ iff }\quad \theta < \pi \\
            \lvert \vec{u} \times \vec{v} \rvert &= 0 \quad\text{ iff }\quad \theta = \pi \\
            \lvert \vec{u} \times \vec{v} \rvert &> 0 \quad\text{ iff }\quad \theta > \pi
          \end{align*}
      \ei
    \end{column}
  \end{columns}
\end{frame}

\subsection{Counterclockwise}
\begin{frame}
  \begin{columns}
    \begin{column}{0.4\textwidth}
      \begin{figure}
        \footnotesize
        \begin{tikzpicture}
          \coordinate(A) at (0,0);
          \coordinate(B) at (2,2);
          \coordinate(C) at (0,4);
          \coordinate(D) at (-1,2);

          \coordinate(E) at (1,0);
          \coordinate(F) at (1,2);
          \coordinate(G) at (1,4);

          \visible<1-3>{
            \draw[hilight,fill] (A) circle[radius=2pt];
            \draw[hilight,fill] (B) circle[radius=2pt];
            \draw[hilight,fill] (C) circle[radius=2pt];
            \draw (A) node[below=10pt] {$A$};
            \draw (B) node[right=20pt] {$B$};
            \draw (C) node[above right] {$C$};
          }

          \visible<1-2>{
            \draw[thick,hilight,->] (B) -- node[above right] {$\vec v$} (C);
            \draw[thick,hilight,->] (B) -- node[below right] {$\vec u$} (A) ;
          }

          \visible<2>{
            \tkzDrawPolygon[fill=title,opacity=0.3](A,B,C);
            \draw (B) node[left=20pt] {\Large$+$};
            \draw[outer color=title,fill=title,opacity=0.5] (B) -- ++(135:.35cm) arc (135:225:.35cm);
          }

          \visible<3>{
            \tkzDrawPolygon[fill=vhilight,opacity=0.2](A,B,C);
            \draw (B) node[left=20pt] {\Large$-$};
            \draw[thick,hilight,->] (B) -- node[above right] {$\vec u$} (C);
            \draw[thick,hilight,->] (B) -- node[below right] {$\vec v$} (A) ;
            \draw[outer color=title,fill=title,opacity=0.5] (B) -- ++(225:.35cm) arc (225:495:.35cm);
          }

          \visible<4>{
            \draw[thick,hilight,->] (F) -- node[right] {$\vec v$} (E);
            \draw[thick,hilight,->] (F) -- node[right] {$\vec u$} (G) ;
            \draw[hilight,fill] (E) circle[radius=2pt];
            \draw[hilight,fill] (F) circle[radius=2pt];
            \draw[hilight,fill] (G) circle[radius=2pt];
            \draw (E) node[below right] {$A$};
            \draw (F) node[right] {$B$};
            \draw (G) node[above right] {$C$};
          }

        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.7\textwidth}
      %\footnotesize
      \bi
        \only<1-2>{
          \item Given three points $A$, $B$ and $C$, we want to know if they form
            a counter-clockwise angle in that order.
            \[
              A \rightarrow B \rightarrow C
            \]
          }
        \only<2>{
          \item We can examine the cross product of and the area of the triangle formed by
            \begin{align*}
              \vec{u} = B - C &\quad \vec{v} = B - A \\
              \vec{u} &\times \vec{v} > 0
            \end{align*}
        }

        \only<3->{
          \item The points in the reverse order do not form a counter clockwise angle.
            \[
              C \rightarrow B \rightarrow A
            \]
          \item In the reverse order the vectors swap places
            \begin{align*}
              \vec{u} = B - A &\quad \vec{v} = B - C \\
              \vec{u} &\times \vec{v} < 0
            \end{align*}
        }

        \only<4>{
          \item If the points $A$, $B$ and $C$ are on the same line, then the area will be $0$.
        }
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \vspace{20pt}
  \begin{minted}{cpp}
double cross(pt a, pt b) {
    return a.x*b.y - a.y*b.x;
}

// 1=ccw, 0=straight, -1=cw
int ccw(pt p0, pt p1, pt p2) {
    coord d1 =(p1.x-p0.x)*(p2.y-p0.y);
    coord d2 =(p2.x-p0.x)*(p1.y-p0.y);
    return (d1-d2>eps)-(d2-d1>eps);
}
  \end{minted} 
  \  \pause
  \bi
 	\item Integer-safe
  \ei
\end{frame}

\subsection{Lines and line segments}
\begin{frame}[fragile]
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{figure}
        \footnotesize
        \begin{tikzpicture}
          \draw[step=.5cm, very thin, foreground, opacity=0.2] (0,0) grid (5,5);
          \draw[thick, ->] (1,1) -- (0,1);
          \draw[thick, ->] (1,1) -- (5,1);
          \draw[thick, ->] (1,1) -- (1,0);
          \draw[thick, ->] (1,1) -- (1,5);
          \visible<1>{
            \draw[hilight,fill] (1.5,3) circle[radius=2pt];
            %\draw (1.5,3) node[anchor=south] {\scriptsize$(1,4)$};
            \draw[hilight,fill] (4,2) circle[radius=2pt];
            %\draw (4,2) node[anchor=north west] {\scriptsize$(6,2)$};
            \draw[hilight,thick] (1.5,3) -- (4,2);
          }

          \visible<1-2>{
            \draw[hilight,fill] (2.5,1.5) circle[radius=2pt];
            \draw[hilight,fill] (4.5,4.5) circle[radius=2pt];
            \draw[hilight,thick] (2.5,1.5) -- (4.5,4.5);
          }

          \visible<2>{
            \draw (2.5,1.5) node[anchor=north west] {{\color{hilight}$p_0$}};
            \draw (4.5,4.5) node[anchor=north west] {{\color{hilight}$p_1$}};
            \draw[vhilight,very thick,->] (1,1) -- (3,4);
            \draw (3,4) node[anchor=south east] {{\color{vhilight}$p_1 - p_0$}};
          }

          \visible<3>{
            \draw[title,very thick] (1,1) -- (3,1);
            \draw[title,very thick] (3,1) -- (3,4);
            \draw[vhilight,very thick,->] (1,1) -- (3,4);
            \draw (3,4) node[anchor=south east] {{\color{vhilight}$p_1 - p_0$}};
          }
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.55\textwidth}
      \bi
        \item Line segments are represented by a pair of points, $((x_0,y_0), (x_1,y_1))$.
        \onslide<2->
        \item Distance between two points is the length of the line segment or vector between the points.
          \onslide<3->
          \begin{align*}
            d((x_0, &y_0), (x_1,y_1)) \\
            &= \lvert(x_1 - x_0, y_1 - y_0)\rvert \\
            &= \texttt{len(x-y)}
          \end{align*}
  \onslide<4-> \item \textbf{Not} Integer-safe
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{figure}
        \footnotesize
        \begin{tikzpicture}
          \draw[step=.5cm, very thin, foreground, opacity=0.2] (0,0) grid (5,5);
          \draw[thick, ->] (1,1) -- (0,1);
          \draw[thick, ->] (1,1) -- (5,1);
          \draw[thick, ->] (1,1) -- (1,0);
          \draw[thick, ->] (1,1) -- (1,5);
            \draw[hilight,fill] (1.5,3) circle[radius=2pt];
            \draw[hilight,fill] (2.75,2.5) circle[radius=2pt];
            %\draw (1.5,3) node[anchor=south] {\scriptsize$(1,4)$};
            \draw[hilight,fill] (4,2) circle[radius=2pt];
            %\draw (4,2) node[anchor=north west] {\scriptsize$(6,2)$};
            \draw[hilight,thick] (1.5,3) -- (4,2);
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.55\textwidth}
      \bi
        \item Given a segment $(\vec{x_1},\vec{x_2})$ and a point $\vec p$.
        Is the point on the segment? \pause
        \item Only possible if $\texttt{ccw} = 0$
        \item $\vec{p}$'s x-Coordinate must be between $\vec{x_1}$'s and $\vec{x_2}$'s
        \item Same for the y-Coodinate
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \vspace{20pt}
  \begin{minted}{cpp}
// 0 = no, 1= on-end-point, 2=strict
int isPointOnSegment(pt p, pt a0, pt a1) {
    if(ccw(a0,a1,p)) return 0;
    coord cx = (p.x-a0.x)*(p.x-a1.x);
    coord cy = (p.y-a0.y)*(p.y-a1.y);
    if(cx > eps || cy > eps) return 0;
    if(cx < -eps || cy < -eps) return 2;
    return 1;
}
  \end{minted} 
  \ \\ \pause
  \bi
 	\item Integer-safe
  \ei
\end{frame}


\begin{frame}[fragile]
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{figure}
        \footnotesize
        \begin{tikzpicture}
          \draw[step=.5cm, very thin, foreground, opacity=0.2] (0,0) grid (5,5);
          \draw[thick, ->] (1,1) -- (0,1);
          \draw[thick, ->] (1,1) -- (5,1);
          \draw[thick, ->] (1,1) -- (1,0);
          \draw[thick, ->] (1,1) -- (1,5);
          
          \draw[hilight,fill] (2,3) circle[radius=2pt];
          \draw[hilight,fill] (4,2) circle[radius=2pt];
          \draw[hilight,thick] (2,3) -- (4,2);

          \draw[hilight,fill] (2.5,1.5) circle[radius=2pt];
          \draw[hilight,fill] (4,4.5) circle[radius=2pt];
          \draw[hilight,thick] (2.5,1.5) -- (4,4.5);        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.55\textwidth}
      \bi
        \item Given two segments $(\vec{x_1},\vec{x_2})$ and $(\vec{y_1},\vec{y_2})$.
        Do they intersect?
        \item Use \texttt{isPointOnSegment} and \texttt{ccw}
      \ei
    \end{column}
  \end{columns}
\end{frame}




\begin{frame}[fragile]
  \vspace{20pt}
  \scriptsize
  \begin{minted}{cpp}
// 0 = none, 1=on-end-point, 2=strict
int isSegmentIntersect(pt a0, pt a1, pt b0, pt b1) {
    int c1=ccw(a0,a1,b0);
    int c2=ccw(a0,a1,b1);
    int c3=ccw(b0,b1,a0);
    int c4=ccw(b0,b1,a1);
    if(c1*c2>0 || c3*c4>0) return 0;
    if(!c1 && !c2 && !c3 && !c4) {
        c1=isPointOnSegment(a0,b0,b1);
        c2=isPointOnSegment(a1,b0,b1);
        c3=isPointOnSegment(b0,a0,a1);
        c4=isPointOnSegment(b1,a0,a1);
        if(c1 && c2 && c3 && c4)
            return 1+(a0.x!=a1.x || a0.y!=a1.y);
        return max(max(c1,c2),max(c3,c4));
    }
    return 1+(!c1 || !c2 || !c3 || !c4));
}
  \end{minted} 
  \pause \normalsize
  \bi
 	\item Integer-safe
  \ei
\end{frame}


\begin{frame}[fragile]
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{figure}
        \footnotesize
        \begin{tikzpicture}
          \draw[step=.5cm, very thin, foreground, opacity=0.2] (0,0) grid (5,5);
          \draw[thick, ->] (1,1) -- (0,1);
          \draw[thick, ->] (1,1) -- (5,1);
          \draw[thick, ->] (1,1) -- (1,0);
          \draw[thick, ->] (1,1) -- (1,5);

          \draw[hilight,fill] (2,3) circle[radius=2pt];
          \draw[hilight,fill] (4,2) circle[radius=2pt];
          \draw[hilight,thick] (2,3) -- (4,2);

          \draw[hilight,fill] (2.5,1.5) circle[radius=2pt];
          \draw[hilight,fill] (4,4.5) circle[radius=2pt];
          \draw[hilight,thick] (2.5,1.5) -- (4,4.5);

          \visible<2>{
            \draw (4,2) node[anchor=north east] {{\color{vhilight}$q_1$}};
            \draw (4,4.5) node[anchor=north west] {{\color{vhilight}$p_1$}};
            \draw (2,3) node[anchor=south] {{\color{vhilight}$q_0$}};
            \draw (2.5,1.5) node[anchor=north west] {{\color{vhilight}$p_0$}};
          }
          \visible<2->{
            \draw[hilight,thick] (5,1.5) -- (0,4);
            \draw[hilight,thick] (1.75,0) -- (4.25,5);

            \draw[vhilight,fill] (2,3) circle[radius=2pt];
            \draw[vhilight,fill] (4,2) circle[radius=2pt];

            \draw[vhilight,fill] (2.5,1.5) circle[radius=2pt];
            \draw[vhilight,fill] (4,4.5) circle[radius=2pt];
          }

          \visible<3->{
            \draw[vhilight,fill] (4,2) circle[radius=2pt];
            \draw[title,very thick,->] (2,3) -- (4,2);
            \draw[vhilight,fill] (2,3) circle[radius=2pt];

            \draw[vhilight,fill] (4,4.5) circle[radius=2pt];
            \draw[title,very thick,->] (2.5,1.5) -- (4,4.5);
            \draw[vhilight,fill] (2.5,1.5) circle[radius=2pt];

            \draw (2,3) node[anchor=south] {{\color{vhilight}$p_1$}};
            \draw (2.5,1.5) node[anchor=north west] {{\color{vhilight}$p_0$}};

            \draw (3.5,3.5) node[anchor=west] {{\color{title}$\vec{r_0}$}};
            \draw (4,2.3) node[anchor=south east] {{\color{title}$\vec{r_1}$}};
          }
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.6\textwidth}
      %\vspace{20pt}
      \bi
        \item Line representation same as line segments.
        \onslide<2->
        \item Treat them as lines passing through the two points.
        \onslide<3->
        \item Or as a point and a direction vector.
          \[
            {\color{vhilight!70}p} + {\color{hilight!70}t} \cdot {\color{title!80}\vec{r}}
          \]
        \onslide<4->
        \vspace{-10pt}
        \item Either way
          \begin{minted}{cpp}
pair<pt,pt>
          \end{minted}
      \ei
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  Very common task is to find the intersection of two lines or line segments.
%  \bi
%    \onslide<2->
%    \item Given a pair of points $(x_0, y_0)$, $(x_1, y_1)$, representing a
%      line we want to start by obtaining the form $Ax + By = C$.
%    \onslide<3->
%    \item We can do so by setting
%      \begin{align*}
%        A &= y_1 - y_0 \\
%        B &= x_0 - x_1 \\
%        C &= A\cdot x_0 + B\cdot y_1
%      \end{align*}
%    \onslide<4->
%    \vspace{-10pt}
%    \item If we have two lines given by such equations, we simply need to solve
%      for the two unknowns, $x$ and $y$.
%  \ei
%\end{frame}

%\begin{frame}
%  For two lines
%  \begin{align*}
%    A_0 x + B_0 y = C_0  \\
%    A_1 x + B_1 y = C_1
%  \end{align*}
%  The intersection point is
%  \begin{align*}
%      x &= \frac{(B_1 \cdot C_0 - B_0 \cdot C_1)}{D} \\
%      y &= \frac{(A_0 \cdot C_1 - A_1 \cdot C_0)}{D}
%  \end{align*}
%  Where
%  \[
%    D = A_0 \cdot B_1 - A_1 \cdot B_0
%  \]
%\end{frame}

%\begin{frame}[fragile]
  \vspace{20pt}
  \begin{minted}{cpp}
// (oo,0)=same, (oo,_)=parallel, (x,y)=point
pt lineIntersect(pt a0, pt a1, pt b0, pt b1) {
    pt d13=a0-b0;
    pt d43=b1-b0;
    pt d21=a1-a0;
    coord un = d43.x*d13.y - d43.y*d13.x;
    coord ud = d43.y*d21.x - d43.x*d21.y;
    if(abs(ud)<eps) return pt(oo,un);
    return pt(a0.x + un*d21.x/ud, a0.y + un*d21.y/ud);
}
  \end{minted} 
  \ \\ \pause
  \bi
 	\item \textbf{Not} integer-safe
  \ei
\end{frame}


\subsection{Circles}
\begin{frame}[fragile]
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{figure}
        \footnotesize
        \begin{tikzpicture}
          \draw[step=.5cm, very thin, foreground, opacity=0.2] (0,0) grid (5,5);
          \draw[thick, ->] (1,1) -- (0,1);
          \draw[thick, ->] (1,1) -- (5,1);
          \draw[thick, ->] (1,1) -- (1,0);
          \draw[thick, ->] (1,1) -- (1,5);

          \draw[hilight,thick] (2,2) circle[radius=1.5cm];
          \draw[hilight,thick] (4,2.5) circle[radius=0.9cm];
          %\draw (3,4) node[anchor=north west] {\scriptsize$(3,6)$};

          \visible<2->{
            \draw[title,fill] (2,2) circle[radius=2pt];
            \draw (2,2) node[anchor=north] {$p_0$};
            \draw[title,fill] (4,2.5) circle[radius=2pt];
            \draw (4,2.5) node[anchor=north] {$p_1$};
          }

          \visible<3->{
            %\draw (2,2) -- (0,10);
            \draw[vhilight,very thick] (2,2) --  +(117:1.5cm) ;
            \draw[vhilight,very thick] (4,2.5) --  +(117:0.9cm) ;
            \draw (2,2.5) node[anchor=south] {$r_0$};
            \draw (4,2.8) node[anchor=south] {$r_1$};
          }
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.5\textwidth}
      \vspace{20pt}
      \bi
        \item Circles are very easy to represent.
        \onslide<2->
        \item Center point ${\color{title!80}p = (x,y)}$.
        \onslide<3->
        \item And the radius ${\color{vhilight!70}r}$.
        \onslide<4->
        \begin{minted}{cpp}
pair<point,double>
        \end{minted}
      \ei
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  Quite similar problem is to find the intersections of two circles.
  \begin{columns}
    \begin{column}{0.6\textwidth}
      \begin{figure}
        \begin{tikzpicture}[auto,swap]
          \scriptsize
          \coordinate (A) at (0,0);
          \coordinate (B) at (3,0);

          \coordinate (P) at (1.2083333,0);
          \coordinate (Q) at (1.2083333,0.88878037);
          \coordinate (R) at (1.2083333,-0.88878037);

          \draw[title,thick] (A) -- node[above left] {$r_A$} (Q);
          \draw[title,thick] (B) -- node[above right] {$r_B$} (Q);

          \draw (A) node[left] {\scriptsize$A$};
          \draw (B) node[right] {\scriptsize$B$};
          \draw[fill,vhilight] (A) circle[radius=1.2pt];
          \draw[fill,vhilight] (B) circle[radius=1.2pt];
          \draw[hilight,thick] (A) circle[radius=1.5cm];
          \draw[hilight,thick] (B) circle[radius=2cm];

          \visible<1-5>{
            \draw[vhilight,thick] (A) --  node[below,xshift=5pt] {\scriptsize$d$} (B);
          }

          \visible<6->{
            \draw[gray,thick] (A) circle[radius=1.5cm];
            \draw[gray,thick] (B) circle[radius=2cm];
            \draw[fill,vhilight] (A) circle[radius=1.2pt];
            \draw[fill,vhilight] (B) circle[radius=1.2pt];

            \draw[gray,thick] (P) -- (R);
            \draw[hilight,thick] (Q) -- node[right=7pt] {$h$} (P);

            \draw[vhilight, thick] (A) -- node[below] {$a$} (P);
            \draw[vhilight, thick] (B) -- node[below] {$b$} (P);

            \draw[fill,hilight] (P) circle[radius=1.2pt];
            \draw[fill,hilight] (Q) circle[radius=1.2pt];
            \draw[fill,hilight] (R) circle[radius=1.2pt];
          }

        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.5\textwidth}
      \footnotesize
      \only<2-5>{
        \bi
            \onslide<2-5>{
            \item If $d > r_0 + r_1$ the circles do not intersect.
            }
            \onslide<3-5>{
            \item If $d < \lvert r_0 - r_1 \rvert $, one circles is contained within the other.
            }
            \onslide<4-5>{
            \item If $d = 0$ and $r_0 = r_1$, the circles are the same.
            }
            \onslide<5>{
            \item Let's look at the last case.
            }
        \ei
      }
      \only<6->{
          \bi
            \onslide<6->{
            \item We can solve for the vectors $a$ and $h$ from the equations
                \[
                a^2 + h^2 = r_0^2 \quad b^2 + h^2 = r_1^2
                \]
            }
            \onslide<7->{
            \item We get
                \[
                a = \frac{r_A^2 - r_B^2 + d^2)}{2\cdot d}
                \]
                \[
                h^2 = r_A^2 - a^2
                \]
            }
        \ei
      }
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \footnotesize
  \begin{minted}{cpp}
#define C(p, r) const point &p, double r
int intersect(C(A, rA), C(B, rB), point & res1, point & res2) { 
    double d = abs(B - A);
    if ( rA + rB <  d - EPS || d < abs(rA - rB) - EPS){
      return 0;
    }
    double a = (rA*rA - rB*rB + d*d) / 2*d;
    double h = sqrt(rA*rA - a*a);
    point v = normalize(B - A, a);
    u = normalize(rotate(B-A), h);
    res1 = A + v + u;
    res2 = A + v - u;
    if (abs(u) < EPS){
        return 1;
    }
    return 2;
}
  \end{minted}
\end{frame}

\subsection{Polygons}
\begin{frame}
  \begin{columns}
    \begin{column}{0.4\textwidth}
      \begin{figure}
        \begin{tikzpicture}
          \coordinate(A) at (0,0);
          \coordinate(B) at (3,0);
          \coordinate(C) at (2.7,1.2);
          \coordinate(D) at (3.7,2);
          \coordinate(E) at (2,4);
          \coordinate(F) at (1,1.5);
          \coordinate(G) at (-1,2);

          \coordinate(Dm) at (2.85,2);
          \coordinate(Em) at (2.85,4);

          \coordinate(Ap) at (-1,0);
          \coordinate(Bp) at (-1,0);
          \coordinate(Cp) at (-1,1.2);
          \coordinate(Dp) at (-1,2);
          \coordinate(Ep) at (-1,4);
          \coordinate(Fp) at (-1,1.5);
          \coordinate(Gp) at (-1,2);

          \tkzDrawPolygon[color=foreground](A,B,C,D,E,F,G);

          \visible<3-5>{
            \draw[fill,hilight] (E) circle[radius=2pt];
            \draw[fill,hilight] (D) circle[radius=2pt];
          }

          \visible<4>{\tkzDrawPolygon[color=foreground,fill=title,opacity=0.3,thin](E,D,Dp,Ep);}
          \visible<5>{\tkzDrawPolygon[color=foreground,fill=title,opacity=0.3,thin](Em,Dm,Dp,Ep);}
          \visible<6>{\tkzDrawPolygon[color=foreground,fill=title,opacity=0.3,thin](D,C,Cp,Dp);}
          \visible<7>{\tkzDrawPolygon[color=foreground,fill=title,opacity=0.3,thin](C,B,Bp,Cp);}
          \visible<8>{\tkzDrawPolygon[color=foreground,fill=red!30,opacity=0.3,thin](A,G,Gp,Ap);}
          \visible<9>{\tkzDrawPolygon[color=foreground,fill=red!30,opacity=0.3,thin](G,F,Fp,Gp);}
          \visible<10>{\tkzDrawPolygon[color=foreground,fill=red!30,opacity=0.3,thin](F,E,Ep,Fp);}
        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.6\textwidth}
      \bi
        \item Polygons are represented by a list of points in the order
          representing the edges.
        \onslide<2->
        \item To calculate the area
          \bi
            \onslide<3->
            \item Go clockwise through all edges of the polygon 
            \onslide<4->
            \item Calculate the area of the polygone whose other side is the y-axis\only<5->{, by computing the area of the respective rectangle}
            \onslide<8->
            \item Top-Down and Bottom-Up edges cancel the area outside the polygon out.
          \ei
      \ei
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \vspace{20pt}
  %Very simple code.
  \footnotesize
  \begin{minted}{cpp}
coord twoarea(vector<pt>& poly) {
    int n = sz(poly);
    coord ret = 0;
    FOR(i,0,n)
        ret += (poly[(i+1)%n].x-poly[i].x)*
               (poly[(i+1)%n].y+poly[i].y);
    return abs(ret);
}
  \end{minted} 
  \ \\ \pause
  \bi
  	\item Integer safe, returns double of the polygons area 
  	\item Pick's theorem
  	\bi
  		\item $A = i + \frac{b}{2}-1$
  		\item $i$ -- number of integer points inside the polygon
  		\item $b$ -- number of integer points on the polygons perimeter
  	\ei
  \ei
\end{frame}

\subsection{Convex hull}
\begin{frame}[fragile]
  \bi
    \item Given a set of points, we want to find the convex hull of the points.
    \onslide<2->
    \item The convex hull of points can be visualized as the shape formed by a rubber band around the set of points.
  \ei
  \onslide<3->
  \begin{figure}
    \begin{tikzpicture}
      \coordinate(A) at (0,0);
      \coordinate(B) at (3,0);
      \coordinate(C) at (2.7,1.2);
      \coordinate(D) at (3.7,2);
      \coordinate(E) at (2,4);
      \coordinate(F) at (1,1.5);
      \coordinate(G) at (-1,3);
      \coordinate(H) at (3,4.2);
      \coordinate(I) at (1,2.43);
      \coordinate(J) at (1.45, 2.87);
      \coordinate(K) at (-0.1, 4);
      \coordinate(L) at (-1.1,2.2);
      \coordinate(M) at (-0.3,1.9);

      \draw[fill,hilight] (A) circle[radius=2pt];
      \draw[fill,hilight] (B) circle[radius=2pt];
      \draw[fill,hilight] (C) circle[radius=2pt];
      \draw[fill,hilight] (D) circle[radius=2pt];
      \draw[fill,hilight] (E) circle[radius=2pt];
      \draw[fill,hilight] (F) circle[radius=2pt];
      \draw[fill,hilight] (G) circle[radius=2pt];
      \draw[fill,hilight] (H) circle[radius=2pt];
      \draw[fill,hilight] (I) circle[radius=2pt];
      \draw[fill,hilight] (J) circle[radius=2pt];
      \draw[fill,hilight] (K) circle[radius=2pt];
      \draw[fill,hilight] (L) circle[radius=2pt];
      \draw[fill,hilight] (M) circle[radius=2pt];

      \visible<4->{
        \draw[hilight,thick] (A) -- (B) -- (D) -- (H) -- (K) -- (G) -- (L) -- cycle;
      }
    \end{tikzpicture}
  \end{figure}
\end{frame}

\begin{frame}[fragile]
  \vspace{20pt}
  Graham scan:
  \bi
    \onslide<2->
    \item Pick the point $p_0$ with the lowest $y$ coordinate.
    \onslide<3->
    \item Sort all the points by polar angle with $p_0$.
    \onslide<4->
    \item Iterate through all the points
    \onslide<5->
    \item If the current point forms a clockwise angle with the last two
      points, remove last point from the convex set.
    \onslide<6->
    \item Otherwise, add the current point to the convex set.
  \ei
  \onslide<7->
  Time complexity: \onslide<8-> $O(N \log N)$.
\end{frame}

\begin{frame}
  \begin{figure}
    \begin{tikzpicture}
      \coordinate(A) at (0,0);
      \coordinate(B) at (3,0);
      \coordinate(C) at (2.7,1.2);
      \coordinate(D) at (3.7,2);
      \coordinate(E) at (2,4);
      \coordinate(F) at (1,1.5);
      \coordinate(G) at (-1,3);
      \coordinate(H) at (3,4.2);
      \coordinate(I) at (1,2.43);
      \coordinate(J) at (1.45, 2.87);
      \coordinate(K) at (-0.1, 4);
      \coordinate(L) at (-1.1,2.2);
      \coordinate(M) at (-0.3,1.9);

      %\draw[fill,hilight] (A) circle[radius=2pt];
      \onslide<2->{
        \draw[fill,hilight] (B) circle[radius=2pt];
        \draw[fill,hilight] (C) circle[radius=2pt];
        \draw[fill,hilight] (D) circle[radius=2pt];
        \draw[fill,hilight] (E) circle[radius=2pt];
        \draw[fill,hilight] (F) circle[radius=2pt];
        \draw[fill,hilight] (G) circle[radius=2pt];
        \draw[fill,hilight] (H) circle[radius=2pt];
        \draw[fill,hilight] (I) circle[radius=2pt];
        \draw[fill,hilight] (J) circle[radius=2pt];
        \draw[fill,hilight] (K) circle[radius=2pt];
        \draw[fill,hilight] (L) circle[radius=2pt];
        \draw[fill,hilight] (M) circle[radius=2pt];
        \draw[fill,vhilight] (A) circle[radius=2pt];
      }

      \visible<3-4>{
        \draw[very thin,foreground] (A) -- (B);
        \draw[very thin,foreground] (A) -- (C);
        \draw[very thin,foreground] (A) -- (D);
        \draw[very thin,foreground] (A) -- (E);
        \draw[very thin,foreground] (A) -- (F);
        \draw[very thin,foreground] (A) -- (G);
        \draw[very thin,foreground] (A) -- (H);
        \draw[very thin,foreground] (A) -- (I);
        \draw[very thin,foreground] (A) -- (J);
        \draw[very thin,foreground] (A) -- (K);
        \draw[very thin,foreground] (A) -- (L);
        \draw[very thin,foreground] (A) -- (M);
      }

      \visible<4->{
        \draw (A) node[below] {$p_0$};
        \draw (B) node[right] {$1$};
        \draw (C) node[below left] {$2$};
        \draw (D) node[above right] {$3$};
        \draw (E) node[above] {$7$};
        \draw (F) node[below right] {$5$};
        \draw (G) node[above] {$11$};
        \draw (H) node[above] {$4$};
        \draw (I) node[above] {$8$};
        \draw (J) node[above left] {$6$};
        \draw (K) node[above] {$9$};
        \draw (L) node[above] {$12$};
        \draw (M) node[above] {$10$};
      }

      \visible<5->{
        \draw[fill,vhilight] (B) circle[radius=2pt];

      }
      \visible<5-7>{
        \draw[fill,vhilight] (C) circle[radius=2pt];
      }
      \visible<5>{
        \draw[thick, vhilight] (B) -- (C);
      }
      \visible<5->{
        \draw[thick, vhilight] (A) -- (B);
      }
      \visible<6->{
        \draw[fill,gray] (C) circle[radius=2pt];
      }
      \visible<6->{
        \draw[fill,vhilight] (D) circle[radius=2pt];
      }
      \visible<6->{
        \draw[thick, vhilight] (B) -- (D);
      }
      %\visible<7->{
        %\draw[fill,title] (A) circle[radius=2pt];
        %\draw[thick, title] (A) -- (B);
      %}
      \visible<7>{
        \draw[thick, vhilight] (B) -- (D);
      }
      %\visible<8->{
        %\draw[fill,title] (B) circle[radius=2pt];
        %\draw[thick, title] (B) -- (D);
      %}
      \visible<7->{
        \draw[thick, vhilight] (D) -- (H);
      }
      \visible<7->{
        \draw[fill,vhilight] (H) circle[radius=2pt];
      }
      \visible<8>{
        \draw[thick, vhilight] (H) -- (F);
        \draw[fill,vhilight] (F) circle[radius=2pt];
      }
      \visible<9->{
        \draw[fill,gray] (F) circle[radius=2pt];
      }
      \visible<9>{
        \draw[thick, vhilight] (H) -- (J);
        \draw[fill,vhilight] (J) circle[radius=2pt];
      }
      \visible<10->{
        \draw[fill,gray] (J) circle[radius=2pt];
      }
      \visible<10-11>{
        \draw[thick, vhilight] (H) -- (E);
        \draw[fill,vhilight] (E) circle[radius=2pt];
      }
      %\visible<11-12>{
        %\draw[fill,gray] (E) circle[radius=2pt];
      %}
      \visible<11>{
        \draw[thick, vhilight] (E) -- (I);
        \draw[fill,vhilight] (I) circle[radius=2pt];
      }

      \visible<12->{
        \draw[fill,gray] (E) circle[radius=2pt];
        \draw[fill,gray] (I) circle[radius=2pt];
      }
      \visible<12->{
        \draw[thick, vhilight] (H) -- (K);
      }
      \visible<12->{
        \draw[fill,vhilight] (K) circle[radius=2pt];
      }
      %\visible<13->{
        %\draw[thick, title] (D) -- (H);
        %\draw[fill,title] (D) circle[radius=2pt];
      %}
      \visible<13>{
        \draw[thick, vhilight] (K) -- (M);
        \draw[fill,vhilight] (M) circle[radius=2pt];
      }
      \visible<14->{
        \draw[fill,gray] (M) circle[radius=2pt];
      }
      \visible<14->{
        \draw[thick, vhilight] (K) -- (G);
      }
      \visible<14->{
        \draw[fill,vhilight] (G) circle[radius=2pt];
      }
      %\visible<15->{
        %\draw[fill,title] (H) circle[radius=2pt];
        %\draw[thick, title] (H) -- (K);
      %}
      \visible<15->{
        \draw[thick, vhilight] (G) -- (L);
        \draw[fill,vhilight] (L) circle[radius=2pt];
      }
      %\visible<16->{
        %\draw[fill,title] (K) circle[radius=2pt];
        %\draw[thick, title] (K) -- (G);
      %}
      \visible<16>{
        \draw[thick, vhilight] (L) -- (A);
        \draw[fill,vhilight] (A) circle[radius=2pt];
      }
      \visible<17->{
        \draw[thick, title] (A) -- (B);
        \draw[thick, title] (B) -- (D);
        \draw[thick, title] (D) -- (H);
        \draw[thick, title] (H) -- (K);
        \draw[thick, title] (K) -- (G);
        \draw[thick, title] (G) -- (L);
        \draw[thick, title] (L) -- (A);
        \draw[fill,title] (A) circle[radius=2pt];
        \draw[fill,title] (B) circle[radius=2pt];
        \draw[fill,title] (D) circle[radius=2pt];
        \draw[fill,title] (H) circle[radius=2pt];
        \draw[fill,title] (K) circle[radius=2pt];
        \draw[fill,title] (G) circle[radius=2pt];
        \draw[fill,title] (L) circle[radius=2pt];
      }

    \end{tikzpicture}
  \end{figure}
\end{frame}

\begin{frame}[fragile]
  \scriptsize
  \begin{minted}{cpp}
vector<pt> convexhull(vector<pt> poly) {
    int n = sz(poly), k = 0;
    vector<pt> h(2*n);
    sort(all(poly));
    FOR(i,0,n) {
        while (k > 1 && ccw(h[k-2], h[k-1], poly[i]) <= 0) k--;
        h[k++] = poly[i];
    }
    int t=k;
    FORD(i,0,n-1) {
        while (k>t && ccw(h[k-2], h[k-1], poly[i]) <= 0) k--;
        h[k++] = poly[i];
    }
    h.resize(k>1 ? k-1 : k);
    return h;
}
  \end{minted}
   \ \\ \pause \normalsize
  \bi
  	\item Integer-safe
  	\item Uses Andrew's algorithm, which does not compute angles
  \ei
\end{frame}

\begin{frame}
  \vspace{40pt}
  Many other algorithms exist
  \bi
    \onslide<2->
    \item Gift wrapping aka Jarvis march.
    \onslide<3->
    \item Quick hull, similar idea to quicksort.
    \onslide<4->
    \item Divide and conquer.
  \ei
  \onslide<5->
  Some can be extended to three dimensions, or higher.
\end{frame}

\subsection{Point in convex polygon}
\begin{frame}
  Simple algorithm to check if a point is in a convex polygon.
  \begin{columns}
    \begin{column}{0.6\textwidth}
      \begin{figure}
        \begin{tikzpicture}
          \coordinate(A) at (0,0);
          \coordinate(B) at (3,0);
          \coordinate(C) at (3.7,1.7);
          \coordinate(D) at (3,3);
          \coordinate(E) at (1, 2.7);
          \coordinate(F) at (-0.3,2.4);
          \coordinate(G) at (-0.2,1.2);

          \coordinate(P) at (4,4);
          \coordinate(Q) at (2,2);

          \draw[fill,title] (A) circle[radius=2pt];
          \draw[fill,title] (B) circle[radius=2pt];
          \draw[fill,title] (C) circle[radius=2pt];
          \draw[fill,title] (D) circle[radius=2pt];
          \draw[fill,title] (E) circle[radius=2pt];
          \draw[fill,title] (F) circle[radius=2pt];
          \draw[fill,title] (G) circle[radius=2pt];

          \visible<1-10>{
            \draw[fill,title] (P) circle[radius=2pt];
          }

          \visible<11->{
            \draw[fill,title] (Q) circle[radius=2pt];
          }

          \draw[title,thick] (A) -- (B) -- (C) -- (D) -- (E) -- (F) -- (G) -- cycle;
          \visible<2>{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](A,B,C,D,E,F,G);
          }
          \visible<3-10>{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](A,B,P);
          }
          \visible<4-10>{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](B,C,P);
          }
          \visible<5-10>{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](C,D,P);
          }
          \visible<6-10>{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](D,E,P);
          }
          \visible<7-10>{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](E,F,P);
          }
          \visible<8-10>{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](F,G,P);
          }
          \visible<9-10>{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](G,A,P);
          }

          \visible<11->{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](A,B,Q);
          }
          \visible<12->{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](B,C,Q);
          }
          \visible<13->{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](C,D,Q);
          }
          \visible<14->{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](D,E,Q);
          }
          \visible<15->{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](E,F,Q);
          }
          \visible<16->{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](F,G,Q);
          }
          \visible<17->{
            \tkzDrawPolygon[color=title,fill=title,opacity=0.4,ultra thin](G,A,Q);
          }

        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.5\textwidth}
      \footnotesize
      \bi
        \onslide<2->
        \item We start by calculating the area of the polygon.
        \onslide<3->
        \item To check if our point is contained in the polygon we sum up the
          area of the triangles formed the point and every two adjacent points.
        \onslide<10->
        \item The total area of the triangles is equal to the area of the
          polygon iff the point is inside the polygon.
      \ei
    \end{column}
  \end{columns}
\end{frame}

\subsection{Point in concave polygon}
\begin{frame}
  \vspace{40pt}
  How about non convex polygon?
  \bi
    \onslide<2->
    \item The \emph{even-odd rule} algorithm.
    \onslide<3->
    \item We examine a ray passing through the polygon to the point.
    \onslide<4->
    \item If the ray crosses the boundary of the polygon, then it alternately
      goes from outside to inside, and outside to inside.
  \ei
\end{frame}

\begin{frame}
  \begin{columns}
    \begin{column}{0.6\textwidth}
      \begin{figure}
        \begin{tikzpicture}
            \coordinate(A) at (0,0);
            \coordinate(B) at (3.5,0);
            \coordinate(C) at (2.7,1.2);
            \coordinate(D) at (4.2,3);
            \coordinate(E) at (2.5,1.3);
            \coordinate(F) at (1.7,4);
            \coordinate(G) at (0.8,1.2);
            \coordinate(H) at (-1,2.5);

            \coordinate(P) at (-1.7,1.7);
            \coordinate(Q) at (5,1.7);

            \coordinate(R) at (1,4);
            \coordinate(S) at (0.3, 2);

            \coordinate(O) at (3.4, 1.7);
            \onslide<1-2>{
              \draw[fill,hilight] (O) circle[radius=2pt];
            }

            \tkzInterLL(B,D)(P,Q) \tkzGetPoint{LL1};
            \tkzInterLL(D,E)(P,Q) \tkzGetPoint{LL2};
            \tkzInterLL(E,F)(P,Q) \tkzGetPoint{LL3};
            \tkzInterLL(F,G)(P,Q) \tkzGetPoint{LL4};
            \tkzInterLL(G,H)(P,Q) \tkzGetPoint{LL5};
            \tkzInterLL(H,A)(P,Q) \tkzGetPoint{LL6};

            \tkzInterLL(D,E)(R,O) \tkzGetPoint{LL7};
            \tkzInterLL(E,F)(R,O) \tkzGetPoint{LL8};
            \tkzInterLL(F,G)(R,O) \tkzGetPoint{LL9};

            \tkzInterLL(B,D)(S,Q) \tkzGetPoint{LL10};
            \tkzInterLL(D,E)(S,Q) \tkzGetPoint{LL11};
            \tkzInterLL(E,F)(S,Q) \tkzGetPoint{LL12};
            \tkzInterLL(F,G)(S,Q) \tkzGetPoint{LL13};

            \tkzDrawPolygon[color=foreground,opacity=0.85](A,B,D,E,F,G,H);

            \onslide<2-4>{
              %\tkzDrawPolygon[color=foreground,opacity=0.7](A,B,D,E,F,G,H);
              \draw[vhilight,title] (P) -- (O);
              \draw[fill,hilight] (O) circle[radius=2pt];
            }

            \onslide<3-4>{
              \draw[fill,vhilight] (LL2) circle[radius=2pt];
              \draw[fill,vhilight] (LL3) circle[radius=2pt];
              \draw[fill,vhilight] (LL4) circle[radius=2pt];
              \draw[fill,vhilight] (LL5) circle[radius=2pt];
              \draw[fill,vhilight] (LL6) circle[radius=2pt];
            }

            \onslide<5-6>{
              \draw[vhilight,title] (R) -- (O);
              \draw[fill,hilight] (O) circle[radius=2pt];
            }

            \onslide<6>{
              \draw[fill,vhilight] (LL7) circle[radius=2pt];
              \draw[fill,vhilight] (LL8) circle[radius=2pt];
              \draw[fill,vhilight] (LL9) circle[radius=2pt];
            }

            \onslide<7-8>{
              %\tkzDrawPolygon[color=foreground,opacity=0.7](A,B,D,E,F,G,H);
              \draw[vhilight,title] (Q) -- (S);
              \draw[fill,hilight] (S) circle[radius=2pt];
            }

            \onslide<8>{
              \draw[fill,vhilight] (LL10) circle[radius=2pt];
              \draw[fill,vhilight] (LL11) circle[radius=2pt];
              \draw[fill,vhilight] (LL12) circle[radius=2pt];
              \draw[fill,vhilight] (LL13) circle[radius=2pt];
            }

        \end{tikzpicture}
      \end{figure}
    \end{column}
    \begin{column}{0.5\textwidth}
      \bi
        \onslide<2->
        \item Ray from the outside of the polygon to the point.
        \onslide<3->
        \item Count the number of intersection points.
        \onslide<4->
        \item If odd, then the point is inside the polygon.
        \item If even, then the point is outside the polygon.
        \onslide<5->
        \item Does not matter which ray we pick.
      \ei
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
%  \vspace{20pt}
  \scriptsize
  \begin{minted}{cpp}
// 0=outside, 1=edge, 2=inside
int isInside(pt p, vector<pt>& poly) {
    int numAbove = 0;
    int numIntersects = 0;
    FOR(i,0,sz(poly)) {
        pt p0 = poly[i];
        pt p1 = poly[(i+1)%sz(poly)];
        if(isPointOnSegment(p,p0,p1)) return 1;
        if(p0.y-p.y<=eps && p1.y-p.y<=eps) continue;
        if(p0.y-p.y>eps && p1.y-p.y>eps) continue;
        pt d=p-p0;
        pt d1=p1-p0;
        if(d1.y < 0) d1.y*=-1, d.y*=-1;
        if(d.y*d1.x > d.x*d1.y) {
            if((p0.y-p.y) * (p1.y-p.y) < 0) numIntersects++;
            else  numAbove++;
        }
    }
    return (((numIntersects+(numAbove%2))%2) != 0 ? 2 : 0);
}
  \end{minted}
  \ \\ \pause \normalsize
  \bi
  	\item \textbf{Not} integer-safe
  \ei
\end{frame}


\subsection{Polygon intersection}
\begin{frame}
  \vspace{40pt}
  \bi
    \item The intersection of two convex polygons is always convex
  \ei
\end{frame}


\begin{frame}[fragile]
  \scriptsize
  \begin{minted}{cpp}
vector<pt> intersect(vector<pt>& p1, vector<pt>& p2) {
    vector<pt> tmp;
    FORIT(it,p1) if(isInside(*it,p2))
        tmp.push_back(*it);
    FORIT(it,p2) if(isInside(*it,p1))
        tmp.push_back(*it);
    FOR(i,0,sz(p1)) FOR(j,0,sz(p2))
        if(isSegmentIntersect(p1[i],p1[(i+1)%sz(p1)],
             p2[j],p2[(j+1)%sz(p2)])) {
        pt in = lineIntersect(p1[i],p1[(i+1)%sz(p1)],
                              p2[j],p2[(j+1)%sz(p2)]);
        if(abs(in.x-oo)>eps) tmp.push_back(in);
    }
    return convexhull(tmp); // strict
}
  \end{minted}
  \ \\ \pause \normalsize
  \bi
  	\item \textbf{Not} integer-safe
  \ei
\end{frame}



\subsection{3D Geometry}
\begin{frame}
	\bi
		\item Basically like 2D just with an additional dimension
		\item Planes
		\bi
			\item Hesse normal form: $\vec{p}\cdot\vec{d} = r$
			\item $\vec{d}$ -- normal vector of the plane
			\item $r$ -- distance of the plane from the origin
			\item Can also compute the distance to the plane
		\ei
		\item Spheres
		\bi
			\item Think in terms of polar coordinates ($\phi$,$\lambda$)
			\item Great-circle distance
			\[d = r \arccos\left(\sin \phi_1 \sin \phi_2 + \cos \phi_1 \cos \phi_2 \cos |\lambda_1 - \lambda_2|\right)\]
		\ei
		\item Euler's polyhedron formula
			\[V + A - E = 2\]
	\ei
\end{frame}


%\subsection{Closest pair of points}
%\begin{frame}
%  \vspace{20pt}
%  Given a set of points, we want to find the pair of points with the smallest distance between them. \\
%  \vspace{5pt}
%  Divide and conquer algorithm;
%  \bi
%    \onslide<2->
%    \item Sort points by the $x$-coordinate.
%    \onslide<3->
%    \item Split the set into two equal sized sets by the vertical line of the medial $x$ value.
%    \onslide<4->
%    \item Solve the problem recursively in the left and right subset.
%    \onslide<5->
%    \item Sort the two subsets by the $y$-coordinate.
%    \onslide<6->
%    \item Find the smallest distance among the pair of points which lie on different sides of the line.
%  \ei
%\end{frame}


% TODO: MAYBE Floating point IF NOT COVERED
% TODO: Point representation
% TODO: Line representation
% TODO: Line segment representation
% TODO: Circles
%  - Geometric properties, circumference, area
% TODO: Triangles
%  - Area of a triangle
%  - Point in triangle
% TODO: Rectangles
% TODO: Distance between geometric objects, line-line, point-line
% TODO: Intersections of geometric objects, mainly lines and line segments
% TODO: MAYBE Spheres
% TODO: CCW
% TODO: Polygon
% TODO: Representation of polygon
% TODO: Polygon area
% TODO: Point in Polygon
% TODO: Convexity
% TODO: Convex hull
% TODO: Divide & Conquer
% TODO: Closest pair of points
%
\end{document}

