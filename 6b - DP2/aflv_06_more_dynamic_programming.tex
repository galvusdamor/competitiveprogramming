\documentclass[12pt,t]{beamer}
\usepackage{graphicx}
\setbeameroption{hide notes}
\setbeamertemplate{note page}[plain]

% get rid of junk
\usetheme{default}
\beamertemplatenavigationsymbolsempty
\hypersetup{pdfpagemode=UseNone} % don't show bookmarks on initial view

% font
\usepackage{fontspec}
\setsansfont{TeX Gyre Heros}
\setbeamerfont{note page}{family*=pplx,size=\footnotesize} % Palatino for notes
% "TeX Gyre Heros can be used as a replacement for Helvetica"
% In Unix, unzip the following into ~/.fonts
% In Mac, unzip it, double-click the .otf files, and install using "FontBook"
%   http://www.gust.org.pl/projects/e-foundry/tex-gyre/heros/qhv2.004otf.zip

% named colors
\definecolor{offwhite}{RGB}{249,242,215}
% \definecolor{foreground}{RGB}{255,255,255}
\definecolor{foreground}{RGB}{0,0,0}
% \definecolor{background}{RGB}{24,24,24}
\definecolor{background}{RGB}{255,255,255}
\definecolor{title}{RGB}{107,174,214}
\definecolor{gray}{RGB}{100,100,100}
\definecolor{subtitle}{RGB}{102,255,204}
\definecolor{hilight}{RGB}{20,180,204}
\definecolor{vhilight}{RGB}{255,111,207}
\definecolor{lolight}{RGB}{155,155,155}
%\definecolor{green}{RGB}{125,250,125}

% use those colors
\setbeamercolor{titlelike}{fg=title}
\setbeamercolor{subtitle}{fg=title}
\setbeamercolor{institute}{fg=gray}
\setbeamercolor{normal text}{fg=foreground,bg=background}
\setbeamercolor{item}{fg=foreground} % color of bullets
\setbeamercolor{subitem}{fg=gray}
\setbeamercolor{itemize/enumerate subbody}{fg=gray}
\setbeamertemplate{itemize subitem}{{\textendash}}
\setbeamerfont{itemize/enumerate subbody}{size=\footnotesize}
\setbeamerfont{itemize/enumerate subitem}{size=\footnotesize}

% page number
\setbeamertemplate{footline}{%
    \raisebox{5pt}{\makebox[\paperwidth]{\hfill\makebox[20pt]{\color{gray}
          \scriptsize\insertframenumber}}}\hspace*{5pt}}

% add a bit of space at the top of the notes page
\addtobeamertemplate{note page}{\setlength{\parskip}{12pt}}

% a few macros
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\ig}{\includegraphics}
\newcommand{\subt}[1]{{\footnotesize \color{subtitle} {#1}}}


% title info
\title{Dynamic Programming}
\subtitle{Part 2}
% \subtitle{Theory, Representation, and Algorithms}
\author{Gregor Behnke}
\institute{Institute of Artificial Intelligence\\ Ulm University}
\date{\tiny based on Bjarki Ágúst Guðmundsson's and Tómas Ken Magnússon's\\Competitive Programming}
% \date{\href{http://www.biostat.wisc.edu/~kbroman}{\tt \scriptsize biostat.wisc.edu/{\textasciitilde}kbroman}
% \\[-4pt]
% \href{http://github.com/kbroman}{\tt \scriptsize github.com/kbroman}
% }

% Tikz
\usepackage{tikz}
\usetikzlibrary{arrows,shapes}

% Minted
\usepackage{minted}
\usemintedstyle{tango}
\newminted{cpp}{fontsize=\footnotesize}

% Graph styles
\tikzstyle{vertex}=[circle,fill=black!50,minimum size=15pt,inner sep=0pt, font=\small]
\tikzstyle{selected vertex} = [vertex, fill=red!24]
\tikzstyle{edge} = [draw,thick,-]
\tikzstyle{dedge} = [draw,thick,->]
\tikzstyle{weight} = [font=\scriptsize,pos=0.5]
\tikzstyle{selected edge} = [draw,line width=2pt,-,red!50]
\tikzstyle{ignored edge} = [draw,line width=5pt,-,black!20]


\begin{document}

% title slide
{
    \setbeamertemplate{footline}{} % no page number here
    \frame{
        \titlepage
    }
}


\begin{frame}{Today we're going to cover}
    \vspace{40pt}
    \bi
        \item Dynamic Programming \pause - part II
    \ei
\end{frame}

\begin{frame}{Squares}
    \vspace{20pt}
    \bi
      \item Determine the smallest $n$, s.t. $N$ is the sum of $n$ squares
      \item Use DP over $(i,j)$  -- number of squares necessary to achieve $i$ where the largest square is $j^2$.
      \item Runtime \pause $\mathcal O(N\cdot\sqrt{N}^2) = \mathcal O(N^2)$ \pause
      \item Do we really need $j$?
      \item DP over $(i)$ number of squares necessary to achieve $i$ and 
      \[
    dp(i) = \min_{j = 0}^{\sqrt{i}} 1 + dp(i - j^2)
      \]
      \item Runtime \pause $\mathcal O(N\cdot\sqrt{N})$
    \ei
\end{frame}

\begin{frame}[fragile]{Squares}
    \begin{minted}[fontsize=\footnotesize]{cpp}
int dp[10001];

dp[0] = 0;
FOR(i,1,10001){
    int x = 1;
    dp[i] = oo;
    while (x*x <= i) dp[i] = min(dp[i], dp[i-x*x]+1), x++;
}
    \end{minted}
\end{frame}


\begin{frame}{2D Max Range Sum}
    \vspace{20pt}
    \bi
      \item Extension of 1D Max Range Sum
      \item Iterate over all lines $z$ as (potential) top-most line of the sub-matrix
      \item Iterate over all lines $x$ as (potential) bottom-most line of the sub-matrix
      \item We can now reduce to 1D Max Range Sum via
	\[a[i] = \sum_{j = z}^x a[i][j]\]
      \item Runtime \pause $\mathcal O(n^4)$ \pause
      \item Clever computation of $a[i]$ gives $\mathcal O(n^3)$
    \ei
\end{frame}

\begin{frame}[fragile]{2D Max Range Sum}
    \begin{minted}[fontsize=\footnotesize]{cpp}
int array[101][101];
int maxSum2D(int N){
    int S = 0;
    int pr[100];
    FOR(z, 0, N){
        FOR(i, 0, N) pr[i] = 0;
        FOR(x, z, N){
            int t = 0;
            int s = -oo;
            FOR(i, 0, N){
                pr[i] = pr[i] + array[x][i];
                t = t + pr[i];
                if (t > s) s = t;
                if (t < 0) t = 0;
            }
            if(s > S) S = s;
        }
    }
    return S;
}
    \end{minted}
\end{frame}


% TODO: Longest increasing subsequence
\begin{frame}{Longest increasing subsequence}
    \bi
\item Given an array $a[0]$, $a[1]$, \ldots, $a[n-1]$ of integers, what is the length of the longest increasing subsequence?
    \vspace{15pt}
\item First, what is a subsequence?
\item If we delete zero or more elements from $a$, then we have a subsequence of $a$
    \vspace{5pt}
\item Example: $a = [5,1,8,1,9,2]$
    \vspace{5pt}
\item $[5,8,9]$ is a subsequence
\item $[1,1]$ is a subsequence
\item $[5,1,8,1,9,2]$ is a subsequence
\item $[]$ is a subsequence
\item $[8,5]$ is \textbf{not} a subsequence
\item $[10]$ is \textbf{not} a subsequence
    \ei
\end{frame}

\begin{frame}{Longest increasing subsequence}
    \bi
\item Given an array $a[0]$, $a[1]$, \ldots, $a[n-1]$ of integers, what is the length of the longest increasing subsequence?
    \vspace{5pt}
\item An increasing subsequence of $a$ is a subsequence of $a$ such that the elements are in (strictly) increasing order
    \vspace{5pt}
\item $[5,8,9]$ and $[1,8,9]$ are the longest increasing subsequences of $a = [5,1,8,1,9,2]$

    \vspace{5pt}
\item How do we compute the length of the longest increasing subsequence?
\item There are $2^n$ subsequences, so we can go through all of them
\item That would result in an $O(n2^n)$ algorithm, which can only handle $n\leq 23$
    \vspace{5pt}
\item What about dynamic programming?

    \ei
\end{frame}

\begin{frame}{Longest increasing subsequence}
    \vspace{20pt}
    \bi
\item Let $\mathrm{lis}(i)$ denote the length of the longest increasing subsequence of the array $a[0]$, $\ldots$, $a[i]$
    \vspace{5pt}
\item Base case: $\mathrm{lis}(0) = 1$
\item What about $\mathrm{lis}(i)$?
    \vspace{10pt}
\item We have the same issue as in the maximum sum problem, so let's try changing perspective
    \ei
\end{frame}

\begin{frame}{Longest increasing subsequence}
    \vspace{40pt}
    \bi
\item Let $\mathrm{lis}(i)$ denote the length of the longest increasing subsequence of the array $a[0]$, $\ldots$, $a[i]$, \textit{that ends at $i$}
    \vspace{5pt}
\item Base case: we don't need one
\item $\mathrm{lis}(i) = \mathrm{max}(1, \mathrm{max}_{j \textrm{ s.t. } a[j] < a[i]} \{ 1 + \mathrm{lis}(j) \})$
    \ei
\end{frame}

\begin{frame}[fragile]{Longest increasing subsequence}
    \begin{minted}[fontsize=\footnotesize]{cpp}
int a[1000];
int mem[1000];
memset(mem, -1, sizeof(mem));

int lis(int i) {
    if (mem[i] != -1) {
        return mem[i];
    }

    int res = 1;
    for (int j = 0; j < i; j++) {
        if (a[j] < a[i]) {
            res = max(res, 1 + lis(j));
        }
    }

    mem[i] = res;
    return res;
}
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Longest increasing subsequence}
    \vspace{30pt}

    \bi
        \item And then the longest increasing subsequence can be found by checking all endpoints:
    \ei

    \begin{minted}{cpp}
int mx = 0;
for (int i = 0; i < n; i++) {
    mx = max(mx, lis(i));
}

printf("%d\n", mx);
    \end{minted}
\end{frame}

\begin{frame}{Longest increasing subsequence}
    \vspace{30pt}
    \bi
        \item Time complexity? \pause
            \vspace{10pt}
        \item There are $n$ possible inputs
        \item Each input is computed in $O(n)$ time, assuming recursive calls are $O(1)$
        \item Total time complexity is $O(n^2)$
            \vspace{10pt}
        \item This will be fast enough for $n \leq 1\ 000$, much better than the brute force method!
    \ei
\end{frame}

\begin{frame}{Longest increasing subsequence}
    \vspace{20pt}
    \bi
      \item Can we do better? \pause - Yes
      \item Store 
      \bi
    \item $m[j]$ - index $k$ of the smallest $a[k]$, s.t. there is a LIS of length $j$ ending at $k$
    \item $p[i]$ - the predecessor of $a[i]$ in the LIS ending at $a[i]$
      \ei
      \item $a[m[0]],\dots,a[m[sz(m)]]$ is non-decreasing
      \item Process the array in order
      \bi
    \item If $a[i] > a[m[sz(m)]]$ we have a new longest LIS
    \item Else search of the largest value (index: $j$) smaller than $a[i]$ in $a[m[\cdot]]$. We set replace $m[j] = i$
      \ei
      \item $m[\cdot]$ isn't actually necessary, but only the sequence of values $a[m[\cdot]]$
      \item Runtime? \pause \dots{} Binary Search! $\rightarrow \mathcal O(n \log n)$
    \ei
\end{frame}


\begin{frame}[fragile]{Longest increasing subsequence}
    \begin{minted}[fontsize=\footnotesize]{cpp}
vi LIS(vi A) {
    int N = A.size();
    vi pre(N,-1),erg;
    map<int,int> m;
    map<int,int>::iterator k,l;
    FOR(i, 0, N) if (m.insert(pii(A[i],i)).second) {
        l = k = m.find(A[i]);
        if (l==m.begin()) pre[i]=-1;
        else pre[i]=(--l)->second;
        if ((++k)!=m.end()) m.erase(k);
    }
    for(int j = (--(k = m.end()))->second;j!=-1;j = pre[j])
        erg.push_back(A[j]);
    reverse (erg.begin(),erg.end());
    return erg;
}
    \end{minted}
\end{frame}




% TODO: Longest common subsequence
\begin{frame}{Longest common subsequence}
    \vspace{20pt}
    \bi
\item Given two strings (or arrays of integers) $a[0]$, \ldots, $a[n-1]$ and $b[0]$, \ldots, $b[m-1]$, find the length of the longest subsequence that they have in common.

    \vspace{10pt}
\item $a = $\texttt{"b\underline{an}an\underline{inn}"}
\item $b = $\texttt{"k\underline{anin}a\underline{n}"}
    \vspace{5pt}
\item The longest common subsequence of $a$ and $b$, \texttt{"aninn"}, has length 5
    \ei
\end{frame}

\begin{frame}{Longest common subsequence}
    \vspace{20pt}
    \bi
\item Let $\mathrm{lcs}(i, j)$ be the length of the longest common subsequence of the strings $a[0]$, \ldots, $a[i]$ and $b[0]$, \ldots, $b[j]$

    \vspace{10pt}
\item Base case: $\mathrm{lcs}(-1, j) = 0$
\item Base case: $\mathrm{lcs}(i, -1) = 0$
    \vspace{10pt}
\item $\mathrm{lcs}(i, j) = \mathrm{max} \left\{
    \begin{array}{ll}
        \mathrm{lcs}(i,j-1) & \\
        \mathrm{lcs}(i-1,j) & \\
        1 + \mathrm{lcs}(i-1,j-1) & \textrm{if } a[i] = b[j] \\
    \end{array}
\right.$
    \ei
\end{frame}

\begin{frame}[fragile]{Longest common subsequence}
    \begin{minted}[fontsize=\scriptsize]{cpp}
string a = "bananinn",
       b = "kaninan";
int mem[1000][1000];
memset(mem, -1, sizeof(mem));

int lcs(int i, int j) {
    if (i == -1 || j == -1) {
        return 0;
    }
    if (mem[i][j] != -1) {
        return mem[i][j];
    }

    int res = 0;
    res = max(res, lcs(i, j - 1));
    res = max(res, lcs(i - 1, j));

    if (a[i] == b[j]) {
        res = max(res, 1 + lcs(i - 1, j - 1));
    }

    mem[i][j] = res;
    return res;
}
    \end{minted}
\end{frame}

\begin{frame}{Longest common subsequence}
    \vspace{40pt}
    \bi
        \item Time complexity? \pause
            \vspace{10pt}
        \item There are $n\times m$ possible inputs
        \item Each input is processed in $O(1)$, assuming recursive calls are $O(1)$
        \item Total time complexity is $O(n\times m)$
    \ei
\end{frame}

% TODO: Bitmasks
\begin{frame}{DP over bitmasks}
    \vspace{40pt}
    \bi
        \item Remember the bitmask representation of subsets?
        \item Each subset of $n$ elements are mapped to an integer in the range $0$, \ldots, $2^{n} - 1$
        \item This makes it easy to do dynamic programming over subsets
    \ei
\end{frame}

% TODO: Traveling salesman problem
\begin{frame}{Traveling salesman problem}
    \vspace{10pt}

    \bi
        \item We have a graph of $n$ vertices, and a cost $c_{i,j}$ between each pair of vertices $i, j$. We want to find a cycle through all vertices in the graph so that the sum of the edge costs in the cycle is minimal.

        \vspace{5pt}
        \item This problem is NP-Hard, so there is no known deterministic polynomial time algorithm that solves it

        \vspace{10pt}
        \item Simple to do in $O(n!)$ by going through all permutations of the vertices, but that's too slow if $n > 11$

        \vspace{10pt}
        \item Can we go higher if we use dynamic programming?
    \ei
\end{frame}

\begin{frame}{Traveling salesman problem}
    \vspace{20pt}
    \bi
\item Without loss of generality, assume we start and end the cycle at vertex $0$
    \vspace{10pt}

\item Let $\mathrm{tsp}(i, S)$ represent the cheapest way to go through all vertices in the graph and back to vertex $0$, if we're currently at vertex $i$ and we've already visited the vertices in the set $S$

    \vspace{20pt}
\item Base case: $\mathrm{tsp}(i, \textrm{all vertices}) = c_{i,0}$
\item Otherwise $\mathrm{tsp}(i, S) = \mathrm{min}_{\ j \not\in S\ } \{\ c_{i,j} + \mathrm{tsp}(j, S \cup \{j\})\ \}$
    \ei
\end{frame}

\begin{frame}[fragile]{Traveling salesman problem}
    \begin{minted}[fontsize=\scriptsize]{cpp}
const int N = 20;
const int INF = 100000000;
int c[N][N];
int mem[N][1<<N];
memset(mem, -1, sizeof(mem));

int tsp(int i, int S) {
    if (S == ((1 << N) - 1)) {
        return c[i][0];
    }
    if (mem[i][S] != -1) {
        return mem[i][S];
    }

    int res = INF;
    for (int j = 0; j < N; j++) {
        if (S & (1 << j))
            continue;

        res = min(res, c[i][j] + tsp(j, S | (1 << j)));
    }

    mem[i][S] = res;
    return res;
}
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Traveling salesman problem}
    \vspace{30pt}
    \bi
\item Then the optimal solution can be found as follows:
    \ei

    \vspace{20pt}
    \begin{minted}{cpp}
printf("%d\n", tsp(0, 1<<0));
    \end{minted}
\end{frame}

\begin{frame}{Traveling salesman problem}
    \vspace{30pt}
    \bi
        \item Time complexity? \pause
        \vspace{10pt}
        \item There are $n \times 2^n$ possible inputs
        \item Each input is computed in $O(n)$ assuming recursive calls are $O(1)$
        \item Total time complexity is $O(n^2 2^n)$
            \vspace{10pt}
        \item Now $n$ can go up to about $20$
    \ei
\end{frame}

\begin{frame}[fragile]{Traveling salesman problem}
    % http://xkcd.com/399/
    \vspace{40pt}
    \begin{center}
    \ig[scale=0.4]{travelling_salesman_problem.png}
    \end{center}
\end{frame}

\end{document}

